use strict;
=head2 noise_gate_cube

=for usage

    $output_cube = noise_gate_cube( $input_cube, \%options );

=for ref

This implements a streamed version of C<noise_gate_batch()>.  For NxNxN cubes, it processes
a few images at a time, sending the output into a copy of the input cube.

=cut

use PDL::Options;
use PDL::Constants;
use PDL::NiceSlice;

sub noise_gate_cube {
    my $cube = shift;
    my $u_opt = shift // {};
    my %opt = parse({
	nsub => 12,
	pct  => 50,
	factor => 3,
	mode => 'shot',
	method => 'gate',
	reference => undef,
	window => '3',
	noise_spectrum=>undef
		    },
		    $u_opt
	);

    # Figure out how may images per step
    my $divisor = ( ($opt{window} =~ m/^q/i) ? 4 : 2 );
    my $ocube = zeroes($cube);

    my $step = $opt{nsub}/$divisor;
    my ($ii, $n);
    my $N = pdl(($cube->dim(2)-$opt{nsub})/$step)->floor;

    ##############################
    # Make a minimum from three time slices, unless one gets passed in.
    print "Making minimum values...\n";
    unless(defined($opt{noise_spectrum})) {
	my @mins;
        $opt{noise_spectrum} = "measure";
	print "SLICE 1...\n";
	push(@mins, noise_gate_batch($cube->(:,:,0:$opt{nsub}-1),\%opt));
	print "SLICE 2...\n";
	push(@mins, ngb2($cube->(:,:,($cube->dim(2)/2-$opt{nsub}/2):(($cube->dim(2)/2-$opt{nsub}/2)+$opt{nsub}-1)), \%opt));
	print "SLICE 3...\n";
	push(@mins, noise_gate_batch($cube->(:,:,-$opt{nsub}:-1),\%opt));
	$opt{noise_spectrum} = pdl(@mins)->mv(-1,0)->medover;
    }

    ##############################
    # Process the cube using the prefrobnicated noise spectrum
    for( $ii=$n=0; $ii < $cube->dim(2)-$opt{nsub}; $ii += $step ) {
	print "== Slice $n of $N "." (layer $ii)\n";
	my $pcube = noise_gate_batch($cube->(:,:,$ii:$ii+$opt{nsub}-1),\%opt);
	$ocube->(:,:,$ii:$ii+$opt{nsub}-1) += $pcube;
	$n++;
    }

    return $ocube;
}

