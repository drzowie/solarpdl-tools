use strict;
=head2 noise_gate_batch

=for usage

    $output_cube = noise_gate_batch($input_cube, \%options);

=for ref

Method of cleaning a movie "cube" via noise gating.  First, accumulate
amplitude thresholds from the data themselves.  Then discard Fourier
components whose amplitude does not exceed the threshold by a set
proportion.

Processing happens in "cubies" -- subcubes of a size that is passed
in, in the options hash.  Cubies are merged back into the output cube,
with Hanning windows applied.  The edge condition is whatever rolloff
the windowing function applies.

The data cube is notionally formatted as (x,y,t).  Three dimensions
are required.

By default, noise_gate_batch uses statistics of the input cube itself
to determine a noise spectrum.  An option (C<noise_spectrum=>'measure'>) allows you
to accumulate a noise spectrum and return it.  You can then feed that
spectrum into further calls to C<noise_gate_batch> for consistency
and/or speed.  That is useful for wrappers like C<noise_gate_cube>,
which use C<noise_gate_batch> as an engine to step through a large
data set.


Options are:

=over 3

=item nsub (default 8)

This is the size of the pixel/voxel subregions into which the input
cube will be chopped for processing.

=item mode (default 'shot')

This can be either "shot" or "fixed" and determines the type of
thresholding to be applied.  Use "shot" for simple images whose
additive noise spectrum is dominated by shot noise (e.g., EUV solar
images), use "fixed" for processed images where the additive noise
floor is roughly constant (e.g., magnetograms).

=item reference (default undef)

If present, this is a separate reference image dataset that can be
used for calculating shot noise.  It should either be a single image
that exactly matches the original in size, or an image set that
exactly matches the original cube.  The shot noise is scaled from the
reference image, rather than from the data.

=item pct (default 50)

This is the percentile value of the local spectra, taken across the
population of sub-image segments, to consider the magnitude of the
noise.

=item noise_spectrum (default undef)

This allows you to feed in a noise spectrum measured in an earlier
call to C<noise_gate_batch>.  If you feed in the string "measure",
then the cube is not processed -- only measured.  The noise spectrum
is measured and returned.  You can then feed that noise spectrum
into subsequent calls, and skip measurement.

=item method (default "gate")

This can be either "gate" or "wiener".  In the gate case, Fourier
components less than the noise value, times the 'factor' parameter,
are simply removed.  In the wiener case, each segment has the
on-the-fly Wiener filter applied.  Each Fourier component is
attenuated by the computed value SNR/(SNR+1), where SNR is the value
of the magnitude in the local segment's spectrum, divided by the
"noise" spectrum and the "factor" parameter.

=item window (default "front")

This adjusts the windowing function that is used for apodization.  
Current options are:

=over 3

=item "front" -- do Hanning windowing up front.  

Basic, brutal.

=item "split" -- do split Hanning windowing.

This applies sin(x) up front, another sin(x) in back.  Not guaranteed to work.  

=item "quad" -- use octature windowing

This option does Hanning windowing up front and in back for sin**4
windowing overall.  This is coupled with 4x-per-segment sampling
(instead of 2x-per-segment with normal windowing), so it costs a factor
of 8 in CPU time and memory compared to regular Hanning windows.  But 
the results are very smooth.

=item "verbose" -- be chatty

If set to 1, this prints some status messages as the calculation is happening.

=item "noise_spectrum" -- provide pre-processed noise spectrum

If this is provided, it must either be the string "measure", in which
case the code measures the noise spectrum and returns it instead
of a processed cube, or else a PDL containing a noise spectrum returned
by an earlier call.  

=back

=back

=cut

use PDL::Options;
use PDL::Constants;
use PDL::NiceSlice;
use PDL::FFTW3;

sub noise_gate_batch {
    my $cube = shift;
    my $u_opt = shift // {};

    my %opt = parse( {
	nsub => 8,         # pixels for a subregion
	pct => 50,
	factor => 3,
	mode => 'shot',
	method => 'gate',
	reference => undef,
	window => 'quad',
	verbose=>0,
	noise_spectrum => undef
		     },
		     $u_opt
	);

    unless($opt{method} =~ m/^[gw]/i) {
	die "noise_gate_batch: method must be 'gate' or 'wiener' (value '$opt{method}')";
    }

    unless($opt{window} =~ m/^[fsq]/i) {
	die "noise_gat_batch: windowing method must be 'front' or 'split' or 'quad' (value '$opt{window}')";
    }

    my $out = $cube->new_or_inplace;

    
    # Cut up the cube
    my $nsub_cut = 2;
    if($opt{window} =~ m/^q/i) {
	$nsub_cut = 4;
    }

    my $ndc_dims = (($cube->shape - $opt{nsub}+1)/($opt{nsub}/$nsub_cut))->ceil;

    unless(all($ndc_dims > 0)) { die "Error: cut dims came out to $ndc_dims...\n"; }
    my $corners =  ndcoords( $ndc_dims->list ) * $opt{nsub}/$nsub_cut ;               # make lower left early corners
    $corners += ($cube->shape - $opt{nsub} - $corners->(:,-1,-1,-1))/2;  # center the pattern
    $corners->inplace->floor;
    $corners = $corners->clump(1,2,3)->sever;

    ## Prepare a window function (hanning windows by default, hence the name)
    my $hanning;
    if($opt{window} =~ m/^[fq]/i) {
	print "Windowing..." if $opt{verbose};
	$hanning = sin( (  xvals( $opt{nsub} ) + 0.5) * PI / $opt{nsub} ) ** 2;
    } elsif($opt{window} =~ m/^s/i) {
	print "Half-windowing...\n" if $opt{verbose};
	$hanning = sin( (  xvals( $opt{nsub} ) + 0.5) * PI / $opt{nsub} );
    }

    # If a reference image stack was supplied, find brightness values for each cubie (next block) in the
    # reference stack.  Do this first so we can free the refcubies variable before allocating the main cubies.
    my $ref_sumsqrt;
    if(defined($opt{reference})) {
	print "Storing reference brightnesses..." if ($opt{verbose});
	# To save time, just store the sum of each reference cubie, if reference values are supplied.
	if($opt{reference}->ndims==2){
	    $opt{reference} = $opt{reference}->(:,:,*($cube->dim(2)));
	}
	my $refcubies = $opt{reference}->range($corners,[$opt{nsub},$opt{nsub},$opt{nsub}],'f')->mv(0,-1)->sever;
	$refcubies *= $hanning;
	$refcubies *= $hanning->(*1);
	$refcubies *= $hanning->(*1,*1);
	$ref_sumsqrt = $refcubies->clip(0)->sqrt->sumover->sumover->sumover->(*1,*1,*1);
    }

    # make an array of cubies that is nsub x nsub x nsub x N, and disconnected from the original.
    print "Cutting..." if ($opt{verbose});
    our $cubies = $out->range($corners,[$opt{nsub},$opt{nsub},$opt{nsub}],'f')->mv(0,-1)->sever;
    print "cubies is ".join("x",$cubies->dims)."..." if ($opt{verbose});

    $cubies *= $hanning;
    $cubies *= $hanning->(*1);
    $cubies *= $hanning->(*1,*1);

    my $sumsqrt;
    if($opt{mode} =~ m/^s/i) { # shot noise - calculate sum-of-sqrt before ditching ricubies
	print "Calculating brigtnesses for shot noise..." if ($opt{verbose});
	if(defined($ref_sumsqrt)) {
	    $sumsqrt = $ref_sumsqrt;
	} else {
	    $sumsqrt = $cubies->clip(0)->sqrt->sumover->sumover->sumover->(*1,*1,*1);
	}
    }

    print "Transforming..." if ($opt{verbose});
    #    my $ricubies = pdl($cubies,0)->mv(-1,0);  # (ri) x nsub x nsub x nsub x N
    #    my $fricubies = fft3($ricubies->inplace);
    our $fricubies = rfft3($cubies); # 2 x nsub/2 x nsub/2 x nsub/2 x N
#    undef $cubies;

    print "Mag..." if ($opt{verbose});
    #  my $fmcubies = ($fricubies*$fricubies)->sumover->sqrt; # nsub x nsub x nsub x N
    our $fmcubies = ($fricubies * $fricubies)->sumover->sqrt; # nsub/2 x nsub/2 x nsub/2 x N
    
    # Convert percentile into an index for future converted cubies
    my $c_n = floor( $opt{pct}/100  * $fmcubies->dim(3) ) ;
    print "select percentile (n=$c_n)..." if ($opt{verbose});

    if($opt{mode} =~ m/^s/i) {  # shot noise
	print "shot noise: scaling by sum(sqrt)..." if ($opt{verbose});
	$fmcubies /= $sumsqrt + 1e-20 * ($sumsqrt==0);
    } elsif( $opt{mode} =~ m/^f/i) { # fixed noise
        print "Finding fixed noise floor..." if ($opt{verbose});
    }

    # Calculate thresholds.  Do this from the statistics of the fmcubies, or use a passed-in mincube.
    my $mincubie;
    if(defined($opt{noise_spectrum}) && UNIVERSAL::isa($opt{noise_spectrum},'PDL')) {
	if($opt{noise_spectrum}->ndims == 3  and  all($opt{noise_spectrum}->shape == $fmcubies->(:,:,:,(0))->shape)) {
	    $mincubie = $opt{noise_spectrum}->copy;
	} else {
	    die "Passed-in noise spectrum has the wrong shape!";
	}
    } elsif(!$opt{noise_spectrum} or  $opt{noise_spectrum} =~ m/^m/i) {
	## Default path here:  calculate the mincubie (threshold) from the fmcubies
	
	$mincubie = $fmcubies->mv(3,0)->qsort->(($c_n))->sever;

	## If we are just measuring, then return that and be done.
	if($opt{noise_spectrum} =~ m/^m/i) {
	    print "\n" if ($opt{verbose});
	    return $mincubie;
	}
    } else {
	## We got a noise_spectrum option and it isn't "measure" and it isn't a PDL.  WTF?
	die "unknown noise_spectrum option '$opt{noise_spectrum}'";
    }

    
    my $filter;
    if($opt{method} =~ m/^g/i) {
	print "Computing threshold filters...\n" if ($opt{verbose});
	$mincubie *= $opt{factor};
	$fmcubies->range([-1,-1,-1],[3,3,3],'p').= 1e15;
	$filter = ($fmcubies >= $mincubie);
    } elsif($opt{method} =~ m/^w/i) {
	print "Computing Wiener filters...\n" if ($opt{verbose});
	# Wiener filter is (SNR/SNR+1).  Calculate SNR, adjusted for the optional factor.
	$filter = $fmcubies / (1e-9 + $mincubie * ($opt{factor} || 1));
	$filter->range([-1,-1,-1],[3,3,3],'p') .= 1e9;  # assume infinite SNR in 0 band
	$filter /= ($filter + 1);
    }

    print "Applying filters...\n" if ($opt{verbose});
    $fricubies->((0)) *= $filter;
    $fricubies->((1)) *= $filter;


    print "Inverse transforming..." if ($opt{verbose});
    #   my $rcubies = ifft3($fricubies->inplace)->((0))->sever;
    my $rcubies = irfft3($fricubies);
    $out .= 0;

    if($opt{window} =~ m/^[sq]/i) {
	print "finishing windowing..." if ($opt{verbose});
	$rcubies *= $hanning;
	$rcubies *= $hanning->(*1);
	$rcubies *= $hanning->(*1,*1);
    }
    if($opt{window} =~ m/^q/i) {
	$rcubies /= 1.5*1.5*1.5;
    }

    print "Merging...\n" if ($opt{verbose});
    for my $i(0..$corners->dim(1)-1){
	$out->range($corners->(:,($i)),[$opt{nsub},$opt{nsub},$opt{nsub}],'f') += $rcubies->(:,:,:,($i));
    }

    return $out;
}

    
