=head2 kminismooth.pdl - make a smoothed image from local minima, using a mask

=for usage

    $smoothed = minismooth_2( $im, $mask, $nth_lowest ); 

=for ref

You feed in an image, a mask, and an nth largest value in each region
to take for the smoothed value.  You get out a minismoothed image.
The process works almost like minismooth, except that instead of a
square region around each pixel kminismooth considers those pixels within
the square region around each pixel, for which the mask kernel evaluates
to TRUE.  The mask kernel is centered on each pixel.  If it has an even
number of points, the extra pixel is kept on the high-coordinate side.

Useful for background subtraction and such, as an alternative to unsharp
masking.

=cut


sub PDL::kminismooth {
    my $im = shift;
    die "kminismooth requires a PDL image (1st param)!" unless(ref($im) eq 'PDL');
    my $mask = shift;
    die "kminismooth requires a PDL mask (2nd param)!" unless(ref($mask) eq 'PDL');
    $mask = !!$mask;
    my $nth = shift // 1;
    die "kminismooth: value of "nth" must be nonnegative and less than mask sum"
    	unless( $nth >= 0  && $nth < ($mask->sum) );
    my $sm = PDL->null;
    PDL::_kminismooth_int($im, $mask, $sm, zeroes($nth+5), $nth);
    $sm2 = $sm->copy;
    return $sm->match([$im->dims],{method=>'l',bound=>'e'})
}

no PDL::NiceSlice;

*kminismooth = \&PDL::kminismooth;
use Inline Pdlpp => <<'EOF';
pp_def('kminismooth',
	Pars=>'im(n,m); mask(t,s); [o]sm(n,m); [t]list(r);',
	OtherPars=>'long nth;',
        PMCode => << 'EOPMC',
EOPMC
	Code => <<'EOC',
	{
	  long i,j,k,l,ii,jj,isk,jsk;
	  long nn,mm;
	  long n_kept;
	  long start_of_n = -$SIZE(t)/2;
	  long start_of_m = -$SIZE(s)/2;
	  $GENERIC() current;
	  
	  for(i=isk=0;  i<$SIZE(m); i++, isk++) {
	    for(j=jsk=0; j<$SIZE(n); j++, jsk++) {
	      n_kept = 0;
	      for(k=0; k < $SIZE(s); k++) {
		for(l=0; l<$SIZE(t); l++) {
		  mm = i+k+start_of_n;
		  nn = j+l+start_of_m;
		  
		  if( nn>=0 && nn < $SIZE(n) && mm >= 0 && mm < $SIZE(m) &&
		      ( $mask(t=>l, s=>k) ) )
		  {
		    current = $im(n=>nn, m=>mm);
		    if( (n_kept < $COMP(nth)) || current < $list(r=>0) ) {
		    // Walk through to find the first number smaller than this one
		       for(ii=0; ii < n_kept && $list(r=>ii) >= current; ii++)
		       ;
		       if(n_kept < $COMP(nth)) {
		       // push stuff on the back
		         for(jj=n_kept; jj>ii; jj--) {
			   $list(r=>jj) = $list(r=>jj-1);
		         }
		       n_kept++;
		      } else {
		        // we're full -- drop stuff off the front
		        ii--;
		        for(jj=0; jj<ii; jj++) {
			  $list(r=>jj) = $list(r=>jj+1);
		        }
		      }
		    
		      $list(r=>ii) = current;
		    }
		  } // end of list maintenance
		} // end of l loop
	      } // end of k loop 
	      $sm(n=>jsk, m=>isk) = $list(r=>0);

	    } // end of j loop
	  } // end of i loop
	} // end of Code
EOC
	);
EOF

1;
