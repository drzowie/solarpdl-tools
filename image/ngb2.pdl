=head2 ngb2 - noise_gate_batch v2

=for ref

(Duplicates the functionality of noise_gate_batch, but without the
horrible range aspect.  This should reduce memory demands and also run
quite a bit faster.)

ngb2 performs cleaning of a movie "cube" via noise gating.  First,
it accumulates amplitude thresholds from the data themselves.  Then
discards or attenuates Fourier components whose amplitude does not
exceed the threshold by a set proportion.

Processing happens in "cubies" -- subcubes of a size that is passed in,
in the options hash.  Cubies are merged back into the output cube, with
Hanning or multi-Hanning windows applied.  The edge condition is whatever
rolloff the windowing function applies.

The data cube is notionally formatted as (x,y,t), though the
interpretation of the dimensions depends on the user.  Three dimensions
are required.

By default, noise_gate_batch uses statistics of the input cube itself
to determine a noise spectrum.  An option (C<noise_spectrum=>'measure'>) allows you
to accumulate a noise spectrum and return it.  You can then feed that
spectrum into further calls to C<noise_gate_batch> for consistency
and/or speed.  That is useful for wrappers like C<noise_gate_cube>,
which use C<noise_gate_batch> as an engine to step through a large
data set.


Options are:

=over 3

=item nsub (default 8)

This is the size of the pixel/voxel subregions into which the input
cube will be chopped for processing.  If you feed in an array ref, 
you can get a different nsub for each dimension.

=item mode (default 'shot')

This can be either "shot" or "fixed" and determines the type of
thresholding to be applied.  Use "shot" for simple images whose
additive noise spectrum is dominated by shot noise (e.g., EUV solar
images), use "fixed" for processed images where the additive noise
floor is roughly constant (e.g., magnetograms).

=item reference (default undef)

If present, this is a separate reference image dataset that can be
used for calculating shot noise.  It should either be a single image
that exactly matches the original in size, or an image set that
exactly matches the original cube.  The shot noise is scaled from the
reference image, rather than from the data.

=item flat (default undef)

If present, this is a flat-field file or vignetting function that
is multiplied with ("de-applied" to) the data before the noise calculation,
then divided out from ("re-applied" to) the data after the noise
calculation. This is useful for working with images where the actual signal at
the detector is divorced from the final calibrated image.

=item pct (default 50)

This is the percentile value of the local spectra, taken across the
population of sub-image segments, to consider the magnitude of the
noise.

=item noise_spectrum (default undef)

This allows you to feed in a noise spectrum measured in an earlier
call to C<noise_gate_batch> or C<ngb2>.  If you feed in the string
"measure", then the cube is not processed -- only measured.  The noise
spectrum is returned.  You can then feed that noise spectrum into
the C<noise_spectrum> option in subsequent calls, and skip measurement.

=item method (default "gate")

This can be either "gate" or "wiener".  In the gate case, Fourier
components less than the noise value, times the 'factor' parameter,
are simply removed.  In the wiener case, each segment has the
on-the-fly Wiener filter applied.  Each Fourier component is
attenuated by the computed value SNR/(SNR+1), where SNR is the value
of the magnitude in the local segment's spectrum, divided by the
"noise" spectrum and the "factor" parameter.

=item window (default "tri")

This adjusts the windowing function that is used for apodization.  
Current options are:

=over 3

=item "front" -- do Hanning windowing up front.  

Basic, brutal.

=item "split" -- do split Hanning windowing.

This applies sin(x) up front, another sin(x) in back.  Not guaranteed
to work.

=item "tri" -- use sextature windowing (recommended & default)

This option does Hanning windowing in up front and in back for sin**4
windowing overall.  This is coupled with 3x-per-segment sampling
(instead of 2x-per-segment with normal windowing) so it costs a factor
of 3.4 in CPU time and memory compared to regular Hanning windows.
Results look equivalent to quad windowing, but at about half the
overall resource hit.

=item "quad" -- use octature windowing

This option does Hanning windowing up front and in back for sin**4
windowing overall.  This is coupled with 4x-per-segment sampling, so
it costs a factor of 8 in CPU time and memory compared to regular
Hanning windows.  This provides the most smooth windowing, but at
significant extra cost compared to "tri".

=back

=item "verbose" -- be chatty

If set to 1, this prints some status messages as the calculation is happening.

=item "noise_spectrum" -- provide pre-processed noise spectrum

If this is provided, it must either be the string "measure", in which
case the code measures the noise spectrum and returns it instead
of a processed cube, or else a PDL containing a noise spectrum returned
by an earlier call.  

=back


=cut

use PDL::NiceSlice;
use PDL::FFTW3;
use PDL::Options;
use strict;

sub ngb2 {
    my $cube = shift;
    my $u_opt = shift // {};
    my $us = "ngb2";
    my %opt = parse({
	nsub=>12,    # default pixels for a subregion
	pct=>50,     # percentile across the batch for each component, to be considered noise
	factor=>3,   # factor by which you have to exceed the component amplitude, to be considered valid
	mode=>'shot',
	method=>'gate',
	flat => undef,
	window=>3,
	verbose=>0,
	noise_spectrum=>undef,
	n_subsamp=>2,  # used to adjust how much of the dataset is used to accumulate the noise spectrum
		    },
		    $u_opt
	);

    unless(ref($opt{nsub})) {
	$opt{nsub} = [$opt{nsub},$opt{nsub},$opt{nsub}];
    }
    if(UNIVERSAL::isa($opt{nsub},'PDL')){
	$opt{nsub} = [$opt{nsub}->list];
    }

    unless($opt{method} =~ m/^[gw]/i) {
	die "$us: method must be 'gate' or 'wiener' (value '$opt{method}')";
    }

    unless($opt{window} == 2 || $opt{window}==3 || $opt{window}==4) {
	die "$us: window must be 2, 3, or 4";
    }

    ## Make a local copy of the input cube (or work on it in-place)
    my $out = $cube->new_or_inplace; 
    
    if(defined($opt{flat})) {
	print "$us: de-applying flat field...\n" if($opt{verbose});
	$out *= $opt{flat};
    }


    ##############################
    # Get noise spectrum (from ngb_fs if necessary)
    our $spec;

    unless(defined($opt{noise_spectrum})) {
	print "$us: Getting noise spectrum... (pct=$opt{pct})" if($opt{verbose}>1);
	$spec = ngb_fs($out, {nsub=>$opt{nsub}, pct=>$opt{pct}, mode=>$opt{mode}, window=>$opt{window}, verbose=>(($opt{verbose}//0)?$opt{verbose}-1:0), subsamp => $opt{n_subsamp}});
    } else {
	$spec = $opt{noise_spectrum}->new_or_inplace;
    }

    ##############################
    # Cut up the dataset, Fourier transform, and calculate adjusted magnitudes
    print "$us: cutting up data...\n" if($opt{verbose});
    my $cubies = cubify3d($out, {nsub=>$opt{nsub}, samp=>$opt{window}, verbose=>$opt{verbose}});

    print "$us: FFT...\n" if($opt{verbose});
    our $fcubies = rfft3($cubies);

    print "$us: magnitude...\n" if($opt{verbose});
    our $fm2cubies = ($fcubies ** 2)->sumover;  # mag-squared to avoid a ton of square roots

    if($opt{mode} =~ m/^s/i) {
	### shot-noise mode: scale by the sum-of-square-roots
	print "$us:finding shot-noise scaling coefficients...\n" if($opt{verbose});
	our $sumsqrt = $cubies->abs->sqrt->sumover->sumover->sumover->clip(1e-20);
	$fm2cubies /= ($sumsqrt**2)->(*1,*1,*1);
    } elsif($opt{mode} =~ m/^m/i) {
	### multiplicative mode: scale by the sum
	print "$us: finding multiplicative scaling coefficients...\n" if($opt{verbose});
	$fm2cubies /= ($cubies->abs->sumover->sumover->sumover->clip(1e-20)**2);
    } else {
	print "$us: using constant noise-spectrum...\n" if($opt{verbose});
    }

    ##############################
    # Do the filtering.

    if($opt{method} =~ m/^g/i) {
	##############################
	# gating:  multiply by fudge factor to get threshold for keepage; square to compare with
	# fm2cubies.

	print "$us: computing gates...\n" if($opt{verbose});
	my $sp2 = ($spec * $opt{factor}) ** 2;
	$sp2->range([0,-1,-1],[2,3,3],'p') .= 0;  # do not zorch low spatial frequencies ever.
	
	PDL::ngb2_gate_helper($fcubies, $fm2cubies, $sp2);
    } else {
        ##############################
	# Wiener: multiply spectrum times fundge-factor; pass in to wiener code (which knows
	# fm2cubies needs the square root taken)
    
	print "$us: computing Wiener  filters...\n" if($opt{verbose});
	my $sp = ($spec * $opt{factor});
	PDL::ngb2_wiener_helper($fcubies, $fm2cubies, $sp);
    }

    print "$us: Inverse-transforming" if($opt{verbose});
    $cubies .= irfft3($fcubies);

    print "$us: reassembling...\n" if($opt{verbose});
    uncubify3d($cubies, {out=>$out,verbose=>$opt{verbose}});


    if(defined($opt{flat})) {
	print "$us: re-applying flat field...\n" if($opt{verbose});
	$out /= $opt{flat} + ($opt{flat}==0);
    }

    print "$us: returning\n";
    return $out;
}
       
no PDL::NiceSlice;
use Inline Pdlpp => <<'EOF';

pp_def('ngb2_gate_helper',
    Pars => '[io]cubies(t); fm2cubies(); spec2()',
    Code => <<'EOC',
       if($spec2() >= $fm2cubies()) {
         loop(t) %{
           $cubies() = 0;
         %}
       }
EOC
);

# wiener filter:  assemble (SNR / SNR + 1) filter.  The SNR is slightly tricky to get at.  The 
# $fm2cubies is the magnitude-squared of the "signal", normalized for estimated noise level 
# adjustment in that piece of image (constant, shot, or multiplicative).  The spec is the 
# constant noise spectrum against which the scaled signal is to be compared.


pp_def('ngb2_wiener_helper',
    Pars => '[io]cubies(t); fm2cubies(); spec2()',
    Code => <<'EOC',
      $GENERIC() snr;
      $GENERIC() filt;
      snr = sqrt( $fm2cubies() ) / $spec2();
      filt = snr/(snr+1);
      $cubies(t=>0) *= filt;
      $cubies(t=>1) *= filt;
EOC
);       

EOF


