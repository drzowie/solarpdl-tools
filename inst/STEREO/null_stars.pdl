=head2 null_stars - hi2 pipeline component

=cut

sub null_stars {
    my $hash = shift;
    my $opt = shift;

    $opt = {} unless defined($opt);

    $opt->{NULL_SMOOTH_FRAMES}=1 unless(defined($opt->{NULL_SMOOTH_FRAMES}));
    $opt->{NULL_SMOOTH_SIZE} = [11,5] unless(defined($opt->{NULL_SMOOTH_SIZE}));
    $opt->{NULL_UNSHARP_FILTER} = 1.0 unless(defined($opt->{NULL_UNSHARP_FILTER}));
    $opt->{NULL_MIN_PCT}     = 10 unless(defined($opt->{NULL_MIN_PCT}));
    #
    # if enough images have a particular place bad, then kill that place
    # in all imamges.  Helps control mask creep...
    my $maskval = ($hash->{CEL_MASK}>0)->mv(2,0)->sumover;
    my $maskratio = $maskval / $hash->{CEL_MASK}->dim(2);
    $hash->{CEL_MASK} *= ($maskratio > 0.25);

    $hash->{CEL_MASK} *= $hash->{CEL_CUBE}->isfinite;

    $hash->{CEL_CUBE}->where(!$hash->{CEL_MASK}) .= 0;


    ##############################
    # Main zeroing procedure - just like F corona, pick a low percentile value as the zero point.
    print "null_stars: finding low percentage value...\n";
    {
	my $qs = $hash->{CEL_CUBE}->mv(-1,0)->qsort;
	my $dex = int( 0.5 + ($hash->{CEL_CUBE}->dim(2)*($opt->{NULL_MIN_PCT}/100)));
	our $qsd = $qs->(($dex),:,:)->sever;
	$hash->{CEL_CUBE} -= $qsd;
    }

    ##############################
    # Next find the places that are *not* properly nulled, and mark 'em bad.
    # bkg is a normalization deal...
    
    our $cc1 = $hash->{CEL_CUBE}->copy;

    print "null_stars: finding residual star locations...\n";
    my $bkg = $hash->{CEL_CUBE}->mv(2,0)->average->med2d(ones(21,21));
    my $k = ((rvals(5,5)==0) - ones(5,5)/25);
    my $usm = $hash->{CEL_CUBE}->copy;
    for $i(0..$usm->dim(2)-1){
    	$usm->(:,:,($i)) .= $hash->{CEL_CUBE}->(:,:,($i))->convolveND($k,bound=>'e');
    }
    $usm /= $bkg;

    our $h2 = $usm->copy;
    
    for my $i(0..$h2->dim(2)-1){ 
	$h2->(:,:,($i)) .= $usm->mv(2,0)->range(pdl($i-2),[5],'e')->medover;
	print "$i ";
    }

    $h->{CEL_CUBE}->badflag(1);
    my $locus = whichND($h2>=3);  # trying 3 instead of original 5
    # Dilate.
    $locus = ($locus - pdl(2,2,0) + ndcoords(5,5,1)->(:,*1))->mv(0,-1)->clump(3)->mv(-1,0)->sever;

    $h->{CEL_CUBE}->range($locus,[0],'e') .= $h->{CEL_CUBE}->badvalue;

    for my $i(1..4){
	print "$i/4 ";
	my $badplaces = whichND($hash->{CEL_CUBE}->isbad);
	print "(".$badplaces->dim(1).")...";
	my $loci = $hash->{CEL_CUBE}->range($badplaces-1,[3,3,3],'e')->mv(0,3)->sever;
	my $vals = $hash->{CEL_CUBE}->range($badplaces,0,'e');
	$vals .= $loci->clump(3)->medover;
    }


    ##############################
    # Now median-smooth the remainder.
    print "null_stars: median-smoothing...\n";
    my $smooth;
    if( ref $opt->{NULL_SMOOTH_SIZE} ) {
	$smooth = ones(pdl($opt->{NULL_SMOOTH_SIZE})->list);
    } else {
	$smooth = ones($opt->{NULL_SMOOTH_SIZE},$opt->{NULL_SMOOTH_SIZE});
    }

    $nframes = int ( ($opt->{NULL_SMOOTH_FRAMES}-1)/2 ) * 2.0 + 1;

    if($nframes <= 1) {
	print "smooth is ",join("x",$smooth->dims);    
	for $i(0..$hash->{CEL_CUBE}->dim(2)-1) {
	    $hash->{CEL_CUBE}->(:,:,($i)) .= $hash->{CEL_CUBE}->(:,:,($i))->med2d($smooth);
	    print ".";
	}
	print "\n";
    } else {
	print "nframes=$nframes\n";
	# Smooth across frames too
	my $c2 = $hash->{CEL_CUBE}->copy;
	for $i(0..$hash->{CEL_CUBE}->dim(2)-1) {
	    my $plane = $c2->range( ndcoords($smooth->dim(0), $smooth->dim(1), $nframes) - pdl($smooth->dim(0)/2,$smooth->dim(1)/2,$nframes/2)->floor + pdl(0,0,$i), 
				    [$c2->dim(0), $c2->dim(1), 0], 'e'
		)->clump(3)->medover;
	    print "$i: plane is ".join("x",$plane->dims)."\n";
	    $hash->{CEL_CUBE}->(:,:,($i)) .= $plane;
	}
    }

    return $hash;
	
}

__END__
    our $foo = $hash->{CEL_CUBE}->copy;
    print "null_stars: sorting smoothed images by value...\n";
    {
	print "dex=$dex\n";
	my $rv = rvals(71,71);
	my $k = exp(-$rv*$rv/15/15);
	$k /= $k->sum;
	our $kk = $k;
	print "null_stars: subtracting zero point...\n";
	$hash->{CEL_CUBE} -= $qsd->convolveND($k,bound=>'e');
    }

    our $bar = $hash->{CEL_CUBE}->copy;

    if($opt->{NULL_UNSHARP_FILTER}) {
	print "null_stars: Unsharp masking to find residual stars...";
	our $ccn2 = $hash->{CEL_CUBE}->copy;
	$ccn2->badflag(0);
	$norm_im = $ccn2->avg;

	$ccn2->inplace->convolveND((rvals(3,3)==0) - ones(3,3)/9,{bound=>'e'});

	print "norm_im is $norm_im...\n";

	my $backstep = int($ccn2->dim(2) * 0.75   +   0.5);
	print "setting level...";
	our $ccn2a = $ccn2->mv(2,0)->qsort->((-$backstep));

	our $badstarmask = ($ccn2a > $norm_im * $opt->{NULL_UNSHARP_FILTER});
	our $badstar_heur = $ccn2a / ($norm_im * $opt->{NULL_UNSHARP_FILTER});
	
	$badstarmask = ($badstarmask->convolveND(ones(5,5)) != 0);
	print "filtering...";
	$hash->{CEL_CUBE} = $hash->{CEL_CUBE}->setbadif($badstarmask);
	print "ok\n";
    }

    # Fill in bad values in four passes
    print "null_stars: repairing cruddy values...";

    $hash->{CEL_CUBE} = $hash->{CEL_CUBE}->setbadif($hash->{CEL_MASK}==0);


    return $hash;
}
    
