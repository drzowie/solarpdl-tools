=head2 motion_filter - hi2 pipeline component

=cut
use PDL::NiceSlice;

sub motion_filter {
    my $hash = shift;
    my $opt = shift;
    
    $opt = {} unless defined($opt);

    $opt->{FILTER_SLOP}= 0.33           unless exists($opt->{FILTER_SLOP});
    $opt->{FILTER_APOD_FRAMES} = 3      unless exists($opt->{FILTER_APOD_FRAMES});
    $opt->{FILTER_APOD_MARGIN} = 20     unless exists($opt->{FILTER_APOD_MARGIN});
    $opt->{FILTER_MASK_TRIGGER} = 0.667 unless exists($opt->{FILTER_MASK_TRIGGER});
    $opt->{FILTER_CUTOFF_PPF} = 1       unless exists($opt->{FILTER_CUTOFF_PPF});
    $opt->{FILTER_CUBE} = "CEL"         unless exists($opt->{FILTER_CUBE});
    $opt->{FILTER_REMOVE_FIXED} = 0     unless exists($opt->{FILTER_REMOVE_FIXED});
    $opt->{FILTER_HYPERSMOOTHING} = 10  unless exists($opt->{FILTER_HYPERSMOOTHING});

    my $of = pdl( $opt->{FILTER_APOD_MARGIN}, 
		   $opt->{FILTER_APOD_MARGIN}, 
		   $opt->{FILTER_APOD_FRAMES} );

    print "motion_filter: of=$of\n";

    my $fc = $opt->{FILTER_CUBE}."_CUBE";
    my $fm = $opt->{FILTER_CUBE}."_MASK";

    print "Apodizing...\n";
    $hash->{$fc}->where($hash->{$fc}->isbad) .= 0;
    $hash->{$fc_UNFILTERED} = $hash->{$fc}->copy;

    print "Masking out points (mask trigger=$opt->{FILTER_MASK_TRIGGER})...";

    for $i(0..$hash->{$fc}->dim(2)-1) {
    	print "$i";
	my $m = ($hash->{$fc}->(:,:,($i))->abs > $opt->{FILTER_MASK_TRIGGER})->convolveND(rvals(11,11)<=5);
	my $wnd = whichND($m);
	print "(".$wnd->dim(1).") ";
	$hash->{$fc}->(:,:,($i)) ->indexND( 0+whichND($m!=0)) .= 0;
    }
	
    my $c3 = ($hash->{$fm} * $hash->{$fc})->range( -$of,
				       2*$of + pdl( $hash->{$fc}->dims ),
				       'm'
	)->sever;
    my $c3i = zeroes($c3);
    print "On initial range: c3 minmax is ".(join(",",$c3->minmax))."\n";

    ## Now apodize the edges with a smooth rolloff...
    my $margin_rolloff = sin( 3.14159 / 2 / $opt->{FILTER_APOD_MARGIN} * xvals($opt->{FILTER_APOD_MARGIN}) );
    $margin_rolloff *= $margin_rolloff;

    $c3->(0:$opt->{FILTER_APOD_MARGIN}-1) *= $margin_rolloff;
    $c3->(-1:-$opt->{FILTER_APOD_MARGIN}:-1) *= $margin_rolloff;
    $c3->(:,0:$opt->{FILTER_APOD_MARGIN}-1)->mv(1,0) *= $margin_rolloff;
    $c3->(:,-1:-$opt->{FILTER_APOD_MARGIN}:-1)->mv(1,0) *= $margin_rolloff;

    my $frames_rolloff = sin( 3.14159 / 2 / $opt->{FILTER_APOD_FRAMES} * xvals($opt->{FILTER_APOD_FRAMES}) );
    $frames_rolloff *= $frames_rolloff;
    
    $c3->(:,:,0:$opt->{FILTER_APOD_FRAMES}-1)->mv(2,0) *= $frames_rolloff;
    $c3->(:,:,-1:-$opt->{FILTER_APOD_FRAMES}:-1)->mv(2,0) *= $frames_rolloff;

    my $filtslop = $opt->{FILTER_SLOP};
    my $filtfunc = sub {
        my $a = shift;
	my $b = shift;
	my $out = $a < $b * (1.0 - $filtslop);
	my $splice = ($a >= $b * (1.0 - $filtslop)) & ($a <= $b * (1.0 + $filtslop));
	my $hump = cos( (3.14159/2) * ($a - $b*(1.0-$filtslop))/(2*$b*$filtslop) );
	return( float($out) + ($hump * $hump * $splice));
    };

    print "After apodization: c3 minmax is ".(join(",",$c3->minmax))."\n";

    print "FFT...";
    ($c3, $c3i) = spawn_fft($c3,$c3i);


    print "filtering...";

    my $cutoff = $opt->{FILTER_CUTOFF_PPF};
    my $nd = ndcoords($c3->(:,:,(0)));
    my $dims = pdl($c3->dim(0),$c3->dim(1));
    $nd -= pdl($dims) * ($nd > $dims/2);
    $nd /= ($dims/2);
    my $rv = ($nd*$nd)->sumover->sqrt;


    if($opt->{FILTER_REMOVE_FIXED}) {
      print "CLOBBERING FIXED COMPONENT\n";
#      $keep = $c3->((0),(0),(0));
      $c3->(:,:,(0)) .= 0;
#      $c3->((0),(0),(0)) .= $keep;
      $c3i->(:,:,(0)) .= 0;
    }

    for $i(1..$c3->dim(2)/2) {
    	print "i=$i ";
	$filtplane = &$filtfunc($rv, $i * $cutoff / ($c3->dim(2)));
	$c3->(:,:,($i)) *= $filtplane;
	$c3i->(:,:,($i)) *= $filtplane;
	$c3->(:,:,(-$i)) *= $filtplane;
	$c3i->(:,:,(-$i)) *= $filtplane;
    }

    $c3->(:,:,(0)) .= 0;
    $c3i->(:,:,(0)) .= 0;

    my $c4 =$c3 -> copy;
    my $c4i=$c3i -> copy;
    
    print "inverse FFT (data)...";
    ($c3, $c3i) = spawn_fft($c3, $c3i, 1);

    undef $c3i;
    $hash->{$fc} .= $c3->range( $of, pdl( $hash->{$fc}->dims ) )->sever;
    undef $c3;



    ##############################
    # Generate hypersmoothed data as a background.  

    print "Filtering...\n";
    $c4dims = pdl($c4->dims);
    $rv2d = rvals($c4dims->(0:1)->list, {center=>[($c4dims->(0:1)/2)->list]})->range($c4dims->(0:1)/2,$c4dims->(0:1),'p')->sever;

    $size = pdl($hash->{$fc}->dim(0)/2/$opt->{FILTER_HYPERSMOOTHING});
    $k2d = exp(-$rv2d*$rv2d / $size / $size);

    $size = $c4->dim(2)/5;
    $wcoord = xvals($c4->dim(2)) - $c4->dim(2) * (xvals($c4->dim(2))>$c4->dim(2)/2);
    for $i(1..$c4->dim(2)/2) {
	my $scale =  $k2d * exp(-$wcoord->at($i)*$wcoord->at($i)/$size/$size);
	$c4->(:,:,$i) *= $scale;
	$c4i->(:,:,$i) *= $scale;
	$c4->(:,:,-$i) *= $scale;
	$c4i->(:,:,-$i) *= $scale;
    }

    print "inverse FFT (smooth)...";
    ($c4, $c4i) = spawn_fft($c4, $c4i, 1);

    print "Finding minima...";
    $c4min = $c4->range($of,pdl($hash->{$fc}->dims))->mv(2,0)->minimum;
    print "subtracting...\n";
    $hash->{$fc} -= $c4min;

    $hash->{$fc} = $hash->{$fc}->setbadif($hash->{$fm}==0);

    print "returning from motion_filter...\n";
    return $hash;
}
    
