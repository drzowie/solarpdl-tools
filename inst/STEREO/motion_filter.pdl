=head2 motion_filter - hi2 pipeline component

=for ref

Options accepted:

=over 3

=item FILTER_APOD_FRAMES

The number of frames (temporal) on either end of the data set that are occupied by the apodization window

=item FILTER_APOD_MARGIN

The number of pixels (spatial) on the data boundary that are occupied by the apodization window

=item FILTER_CUTOFF_PPF

This is the cutoff speed, in pixels per frame

=item FILTER_MAX_SIZE

This is the largest size of object (lowest spatial frequency) that is filtered. The filter is rolled
to allpass at the corresponding spatial frequency, so objects larger than this threshold aren't affected
by the motion filter.

=item FILTER_SLOP

The width of the filter boundary apodization region (fraction of filter cutoff frequency)

=item FILTER_MASK_TRIGGER

Pixels with larger absolute value than this are considered to be noise and are replaced with 0.

=item FILTER_CUBE

This is a string that contains the key prefix for the data cube to filter in the supplied hash.  (usually
"CEL" as the hi-1 and hi-2 pipelines use that cube to hold the celestial-coordinate dataset).

=item FILTER_REMOVE_FIXED

If this is nonzero, the D.C. component of the data is replaced with 0.

=item FILTER_HYPERSMOOTHING

If this is nonzero, then a hypersmoothed copy of the data is used to find the zero value.  It defaults
to 10 (10x hypersmoothing).  If you set it to 0, then no hypersmoothing is performed.   Note that it
makes no sense to do hypersmoothing and also remove the fixed offset with FILTER_REMOVE_FIXED, since
this step obviates the D.C. component anyway.

=back


=cut
use PDL::NiceSlice;

sub motion_filter {
    my $hash = shift;
    my $opt = shift;
    
    $opt = {} unless defined($opt);

    $opt->{FILTER_SLOP}= 0.33           unless exists($opt->{FILTER_SLOP});
    $opt->{FILTER_APOD_FRAMES} = 3      unless exists($opt->{FILTER_APOD_FRAMES});
    $opt->{FILTER_APOD_MARGIN} = 20     unless exists($opt->{FILTER_APOD_MARGIN});
    $opt->{FILTER_MASK_TRIGGER} = 0.667 unless exists($opt->{FILTER_MASK_TRIGGER});
    $opt->{FILTER_MASK_FR_PM}   = 3     unless exists($opt->{FILTER_MASK_FR_PM});
    $opt->{FILTER_US_SIZE}      = 11    unless exists($opt->{FILTER_US_SIZE});
    $opt->{FILTER_DIL_SIZE}     = 5     unless exists($opt->{FILTER_DIL_SIZE});
    $opt->{FILTER_CUTOFF_PPF} = 1       unless exists($opt->{FILTER_CUTOFF_PPF});
    $opt->{FILTER_MAX_SIZE}     = 50    unless exists($opt->{FILTER_MAX_SIZE});
    $opt->{FILTER_CUBE} = "CEL"         unless exists($opt->{FILTER_CUBE});
    $opt->{FILTER_REMOVE_FIXED} = 0     unless exists($opt->{FILTER_REMOVE_FIXED});
    $opt->{FILTER_HYPERSMOOTHING} = 10  unless exists($opt->{FILTER_HYPERSMOOTHING});
    $opt->{FILTER_ZAP_HF} = 0.75   unless exists($opt->{FILTER_ZAP_HF});


    my $of = pdl( $opt->{FILTER_APOD_MARGIN}, 
		   $opt->{FILTER_APOD_MARGIN}, 
		   $opt->{FILTER_APOD_FRAMES} );

    print "motion_filter: of=$of\n";

    my $fc = $opt->{FILTER_CUBE}."_CUBE";
    my $fm = $opt->{FILTER_CUBE}."_MASK";

    print "Apodizing...\n";
    print "fc is $fc\n";
    $hash->{$fc}->where($hash->{$fc}->isbad) .= 0;
    $hash->{$fc."_UNFILTERED"} = $hash->{$fc}->copy;

    print "Masking out points (mask trigger=$opt->{FILTER_MASK_TRIGGER})...";

    for $i(0..$hash->{$fc}->dim(2)-1) {
    	print "$i";
	my $im = $hash->{$fc}->(:,:,($i));
	if($opt->{FILTER_US_SIZE}) {
	    # FILTER_US_SIZE is set -- unsharp-mask the image before masking.
	    my $k = ( (rvals($opt->{FILTER_US_SIZE},$opt->{FILTER_US_SIZE})==0) -   # central spike
		      ones($opt->{FILTER_US_SIZE},$opt->{FILTER_US_SIZE}) / $opt->{FILTER_US_SIZE}**2); # negative boxcar
	    $im = $im->convolveND($k);
	}
		      
	# Make an excessive-value mask, and dilate.
	my $m = (  ($im->abs > $opt->{FILTER_MASK_TRIGGER})
		   ->convolveND(
		       (rvals( $opt->{FILTER_DIL_SIZE}*2+1, $opt->{FILTER_DIL_SIZE}*2+1) <= $opt->{FILTER_DIL_SIZE})
		   )>= 1
	    );	   
	my $wnd = whichND($m);
	print "(".$wnd->dim(1).") ";

	# Mask out a few frames ahead and behind...
	for my $j($i-$opt->{FILTER_MASK_FR_PM}..$i+$opt->{FILTER_MASK_FR_PM}){
	    if($j>=0 and $j< $hash->{$fc}->dim(2)) {
		$hash->{$fc}->(:,:,($j))->indexND(0+whichND($m!=0)) .= 0;
	    }
	}
    }
	
    my $c3 = ($hash->{$fm} * $hash->{$fc})->range( -$of,
				       2*$of + pdl( $hash->{$fc}->dims ),
				       'm'
	)->sever;
    my $c3i = zeroes($c3);
    print "On initial range: c3 minmax is ".(join(",",$c3->minmax))."\n";

    ## Now apodize the edges with a smooth rolloff...
    my $margin_rolloff = sin( 3.14159 / 2 / $opt->{FILTER_APOD_MARGIN} * xvals($opt->{FILTER_APOD_MARGIN}) );
    $margin_rolloff *= $margin_rolloff;

    $c3->(0:$opt->{FILTER_APOD_MARGIN}-1) *= $margin_rolloff;
    $c3->(-1:-$opt->{FILTER_APOD_MARGIN}:-1) *= $margin_rolloff;
    $c3->(:,0:$opt->{FILTER_APOD_MARGIN}-1)->mv(1,0) *= $margin_rolloff;
    $c3->(:,-1:-$opt->{FILTER_APOD_MARGIN}:-1)->mv(1,0) *= $margin_rolloff;

    my $frames_rolloff = sin( 3.14159 / 2 / $opt->{FILTER_APOD_FRAMES} * xvals($opt->{FILTER_APOD_FRAMES}) );
    $frames_rolloff *= $frames_rolloff;
    
    $c3->(:,:,0:$opt->{FILTER_APOD_FRAMES}-1)->mv(2,0) *= $frames_rolloff;
    $c3->(:,:,-1:-$opt->{FILTER_APOD_FRAMES}:-1)->mv(2,0) *= $frames_rolloff;

    my $filtslop = $opt->{FILTER_SLOP};

    my $filtfunc = sub {
        my $a = shift;
	my $b = shift;
	my $z = shift;

	my $out = $a < $b * (1.0 - $filtslop);
	my $splice = ($a >= $b * (1.0 - $filtslop)) & ($a <= $b * (1.0 + $filtslop));
	my $hump = cos( (3.14159/2) * ($a - $b*(1.0-$filtslop))/(2*$b*$filtslop) );

	$out = float($out) + float($hump * $hump * $splice);
	
	if($opt->{FILTER_ZAP_HF}) {
	     my $maskval = ((sqrt($a*$a+$z*$z) - $opt->{FILTER_ZAP_HF}) * 3.14159/2/($opt->{FILTER_ZAP_HF}*0.05))->clip(-3.14159/2,3.14159/2);
	    my $mv = (1 - sin($maskval))/2;
	    $out *= $mv;
	}
	
	return( $out );
    };

    print "After apodization: c3 minmax is ".(join(",",$c3->minmax))."\n";

    print "FFT...";

    # ($c3, $c3i) = spawn_fft($c3,$c3i);
    fftnd($c3,$c3i);

    print "filtering...";

    ##############################
    # rv goes from 0 to 1 over the spatial extent on each axis (up to 1.4 at the corners)
    my $cutoff = $opt->{FILTER_CUTOFF_PPF};
    my $nd = ndcoords($c3->(:,:,(0)));
    my $dims = pdl($c3->dim(0),$c3->dim(1));
    $nd -= pdl($dims) * ($nd > $dims/2);
    $nd /= ($dims/2);
    my $rv = ($nd*$nd)->sumover->sqrt;

    if($opt->{FILTER_REMOVE_FIXED}) {
      print "CLOBBERING FIXED COMPONENT\n";
      $keep = $c3->((0),(0),(0));
      $c3->(:,:,(0)) .= 0;
      $c3->((0),(0),(0)) .= $keep;
      $c3i->(:,:,(0)) .= 0;
    }

    for $i(1..$c3->dim(2)/2) {
    	print "i=$i ";
	my $ct;
	if($opt->{FILTER_MAX_SIZE}) {
	    $ct = $i * 2 * $cutoff / $c3->dim(2);
	    if($ct < 1/$opt->{FILTER_MAX_SIZE}) {
		$ct = 1/$opt->{FILTER_MAX_SIZE};
	    }
	} else {
	    $ct = $i * 2 * $cutoff / $c3->dim(2);
	}
	print "i=$i; ct = $ct\n";

	$filtplane = &$filtfunc($rv, $ct, $i/($c3->dim(2)/2) );

	$c3->(:,:,($i)) *= $filtplane;
	$c3i->(:,:,($i)) *= $filtplane;
	$c3->(:,:,(-$i)) *= $filtplane;
	$c3i->(:,:,(-$i)) *= $filtplane;
    }


#    $c3->(:,:,(0)) .= 0;
#    $c3i->(:,:,(0)) .= 0;

    my $c4 =$c3 -> copy;
    my $c4i=$c3i -> copy;
    
    print "inverse FFT (data)...";

#  ($c3, $c3i) = spawn_fft($c3,$c3i,1);
    ifftnd($c3,$c3i);

    undef $c3i;
    $hash->{$fc} .= $c3->range( $of, pdl( $hash->{$fc}->dims ) )->sever;
    undef $c3;



    ##############################
    # Generate hypersmoothed data as a background.  

    if($opt->{FILTER_HYPERSMOOTHING}) {
        print "Filtering...\n";
	$c4dims = pdl($c4->dims);
	$rv2d = rvals($c4dims->(0:1)->list, {center=>[($c4dims->(0:1)/2)->list]})->range($c4dims->(0:1)/2,$c4dims->(0:1),'p')->sever;
	
	$size = pdl($hash->{$fc}->dim(0)/2/$opt->{FILTER_HYPERSMOOTHING});
	$k2d = exp(-$rv2d*$rv2d / $size / $size);
	
	$size = $c4->dim(2)/5;
	$wcoord = xvals($c4->dim(2)) - $c4->dim(2) * (xvals($c4->dim(2))>$c4->dim(2)/2);
	for $i(1..$c4->dim(2)/2) {
	my $scale =  $k2d * exp(-$wcoord->at($i)*$wcoord->at($i)/$size/$size);
	$c4->(:,:,$i) *= $scale;
	$c4i->(:,:,$i) *= $scale;
	$c4->(:,:,-$i) *= $scale;
	$c4i->(:,:,-$i) *= $scale;
	}
	
	print "inverse FFT (smooth)...";
	
#    ($c4, $c4i) = spawn_fft($c4,$c4i,1)
	ifftnd($c4,$c4i); 
	
	print "Finding minima...";
	$c4min = $c4->range($of,pdl($hash->{$fc}->dims))->mv(2,0)->minimum;
	print "subtracting...\n";
	$hash->{$fc} -= $c4min;
    }

    $hash->{$fc} = $hash->{$fc}->setbadif($hash->{$fm}==0);

    print "returning from motion_filter...\n";
    return $hash;
}
    
