=head2 motion_filter - hi2 pipeline component

=cut

sub motion_filter {
    my $hash = shift;
    my $opt = shift;

    $opt = {} unless defined($opt);

    $opt->{FILTER_SLOP}= 0.33 unless defined($opt->{FILTER_SLOP});
    $opt->{FILTER_APOD_FRAMES} = 3 unless defined($opt->{FILTER_APOD_FRAMES});
    $opt->{FILTER_APOD_MARGIN} = 10 unless defined($opt->{FILTER_APOD_MARGIN});

    my $of = pdl( $opt->{FILTER_APOD_MARGIN}, 
		   $opt->{FILTER_APOD_MARGIN}, 
		   $opt->{FILTER_APOD_FRAMES} );

    print "Apodizing...\n";
    $hash->{CEL_CUBE}->where($hash->{CEL_CUBE}->isbad) .= 0;
    for $i(0..$hash->{CEL_CUBE}->dim(2)-1) {
	my $m = ($hash->{CEL_CUBE}->(:,:,($i)) > 1)->convolveND(rvals(31,31)<=15);
	$hash->{CEL_CUBE}->(:,:,($i)) ->indexND( 0+whichND($m!=0)) .= 0;
    }
	

    our $c3 = $hash->{CEL_CUBE}->range( -$of,
				       2*$of + pdl( $hash->{CEL_CUBE}->dims ),
				       'm'
	)->sever;

    ## Now apodize the edges with a smooth rolloff...
    my $margin_rolloff = sin( 3.14159 / 2 / $opt->{FILTER_APOD_MARGIN} * xvals($opt->{FILTER_APOD_MARGIN}) );
    $margin_rolloff *= $margin_rolloff;

    $c3->(0:$opt->{FILTER_APOD_MARGIN}-1) *= $margin_rolloff;
    $c3->(-1:-$opt->{FILTER_APOD_MARGIN}:-1) *= $margin_rolloff;
    $c3->(:,0:$opt->{FILTER_APOD_MARGIN}-1)->mv(1,0) *= $margin_rolloff;
    $c3->(:,-1:-$opt->{FILTER_APOD_MARGIN}:-1)->mv(1,0) *= $margin_rolloff;

    my $frames_rolloff = sin( 3.14159 / 2 / $opt->{FILTER_APOD_FRAMES} * xvals($opt->{FILTER_APOD_FRAMES}) );
    $frames_rolloff *= $frames_rolloff;
    
    $c3->(:,:,0:$opt->{FILTER_APOD_FRAMES}-1)->mv(2,0) *= $frames_rolloff;
    $c3->(:,:,-1:-$opt->{FILTER_APOD_FRAMES}:-1)->mv(2,0) *= $frames_rolloff;

    my $c3i = zeroes($c3);


    my $filtslop = $opt->{FILTER_SLOP};
    my $filtfunc = sub {
        my $a = shift;
	my $b = shift;
	$out = $a < $b * (1.0 - $filtslop);
	$splice = ($a >= $b * (1.0 - $filtslop)) & ($a <= $b * (1.0 + $filtslop));
	my $hump = cos( (3.14159/2) * ($a - $b*(1.0-$filtslop))/(2*$b*$filtslop) );
	return( float($out) + ($hump * $hump * $splice));
    };

    print "FFT...";
    fftnd($c3, $c3i);
    
    print "filtering...";

    my $filt = ones(float,$c3->dims);
    my $cutoff = 1;
    my $nd = ndcoords($c3->(:,:,(0)));
    my $dims = pdl($c3->dim(0),$c3->dim(1));
    $nd -= pdl($dims) * ($nd > $dims/2);
    $nd /= ($dims/2);
    my $rv = ($nd*$nd)->sumover->sqrt;
    
    for $i(1..$c3->dim(2)/2) {
	$filtplane = &$filtfunc($rv, $i * $cutoff / $c3->dim(2)/2);
	$c3->(:,:,($i)) *= $filtplane;
	$c3i->(:,:,($i)) *= $filtplane;
	$c3->(:,:,(-$i)) *= $filtplane;
	$c3i->(:,:,(-$i)) *= $filtplane;
    }

    $c3->(:,:,(0)) .= 0;
    $c3i->(:,:,(0)) .= 0;

    print "inverse FFT...";
    ifftnd($c3, $c3i);

    $hash->{CEL_CUBE} .= $c3->range( $of, pdl( $hash->{CEL_CUBE}->dims ) )->sever;

    
    print "Finding minima...";
    $bk = $hash->{CEL_CUBE}->convolveND(ones(25,25,5)/25/25/5)->mv(-1,0)->minimum;
    $hash->{CEL_CUBE} -= $bk;
    
    return $hash;
}
    
