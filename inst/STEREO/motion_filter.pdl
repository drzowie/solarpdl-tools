=head2 motion_filter - hi2 pipeline component

=cut

sub motion_filter {
    my $hash = shift;
    my $opt = shift;

    $opt = {} unless defined($opt);

    $opt->{FILTER_SLOP}= 0.33           unless exists($opt->{FILTER_SLOP});
    $opt->{FILTER_APOD_FRAMES} = 3      unless exists($opt->{FILTER_APOD_FRAMES});
    $opt->{FILTER_APOD_MARGIN} = 10     unless exists($opt->{FILTER_APOD_MARGIN});
    $opt->{FILTER_MASK_TRIGGER} = 0.667 unless exists($opt->{FILTER_MASK_TRIGGER});

    my $of = pdl( $opt->{FILTER_APOD_MARGIN}, 
		   $opt->{FILTER_APOD_MARGIN}, 
		   $opt->{FILTER_APOD_FRAMES} );

    print "Apodizing...\n";
    $hash->{CEL_CUBE}->where($hash->{CEL_CUBE}->isbad) .= 0;
    for $i(0..$hash->{CEL_CUBE}->dim(2)-1) {
	my $m = ($hash->{CEL_CUBE}->(:,:,($i))->abs > $opt->{FILTER_MASK_TRIGGER})->convolveND(rvals(31,31)<=15);
	$hash->{CEL_CUBE}->(:,:,($i)) ->indexND( 0+whichND($m!=0)) .= 0;
    }
	

    our $c3 = $hash->{CEL_CUBE}->range( -$of,
				       2*$of + pdl( $hash->{CEL_CUBE}->dims ),
				       'm'
	)->sever;

    ## Now apodize the edges with a smooth rolloff...
    my $margin_rolloff = sin( 3.14159 / 2 / $opt->{FILTER_APOD_MARGIN} * xvals($opt->{FILTER_APOD_MARGIN}) );
    $margin_rolloff *= $margin_rolloff;

    $c3->(0:$opt->{FILTER_APOD_MARGIN}-1) *= $margin_rolloff;
    $c3->(-1:-$opt->{FILTER_APOD_MARGIN}:-1) *= $margin_rolloff;
    $c3->(:,0:$opt->{FILTER_APOD_MARGIN}-1)->mv(1,0) *= $margin_rolloff;
    $c3->(:,-1:-$opt->{FILTER_APOD_MARGIN}:-1)->mv(1,0) *= $margin_rolloff;

    my $frames_rolloff = sin( 3.14159 / 2 / $opt->{FILTER_APOD_FRAMES} * xvals($opt->{FILTER_APOD_FRAMES}) );
    $frames_rolloff *= $frames_rolloff;
    
    $c3->(:,:,0:$opt->{FILTER_APOD_FRAMES}-1)->mv(2,0) *= $frames_rolloff;
    $c3->(:,:,-1:-$opt->{FILTER_APOD_FRAMES}:-1)->mv(2,0) *= $frames_rolloff;

    our $c3i = zeroes($c3);


    my $filtslop = $opt->{FILTER_SLOP};
    my $filtfunc = sub {
        my $a = shift;
	my $b = shift;
	$out = $a < $b * (1.0 - $filtslop);
	$splice = ($a >= $b * (1.0 - $filtslop)) & ($a <= $b * (1.0 + $filtslop));
	my $hump = cos( (3.14159/2) * ($a - $b*(1.0-$filtslop))/(2*$b*$filtslop) );
	return( float($out) + ($hump * $hump * $splice));
    };

    print "FFT...";
    fftnd($c3, $c3i);
    
    print "filtering...";

    my $filt = ones(float,$c3->dims);
    my $cutoff = 1;
    my $nd = ndcoords($c3->(:,:,(0)));
    my $dims = pdl($c3->dim(0),$c3->dim(1));
    $nd -= pdl($dims) * ($nd > $dims/2);
    $nd /= ($dims/2);
    my $rv = ($nd*$nd)->sumover->sqrt;
    
    for $i(1..$c3->dim(2)/2) {
	$filtplane = &$filtfunc($rv, $i * $cutoff / $c3->dim(2)/2);
	$c3->(:,:,($i)) *= $filtplane;
	$c3i->(:,:,($i)) *= $filtplane;
	$c3->(:,:,(-$i)) *= $filtplane;
	$c3i->(:,:,(-$i)) *= $filtplane;
    }

    $c3->(:,:,(0)) .= 0;
    $c3i->(:,:,(0)) .= 0;

    ##############################
    # Generate hypersmoothed data as a background...
    print "Generating smoothed background...\n";
    my $c4 = $c3->copy;
    my $c4i = $c3i->copy;

    $rv2d = rvals($c4->dim(0),$c4->dim(1),{center=>[$c4->dim(0)/2,$c4->dim(1)/2]})->range([-$c4->dim(0)/2,-$c4->dim(1)/2],[$c4->dim(0),$c4->dim(1)],'p');
    $size = pdl($c4->dim(0)/50);
    $k2d = exp(-$rv2d*$rv2d / $size / $size);

    $size = $c4->dim(2)/20;

    $wcoord = xvals($c4->dim(2)) - $c4->dim(2) * (xvals($c4->dim(2))>$c4->dim(2)/2);
    for $i(1..$c4->dim(2)/2) {
	my $scale =  $k2d * exp(-$wcoord->at($i)*$wcoord->at($i)/$size/$size);
	$c4->(:,:,$i) *= $scale;
	$c4i->(:,:,$i) *= $scale;
    }

    print "inverse FFT (data)...";
    ifftnd($c3, $c3i);

    print "inverse FFT (smooth)...";
    ifftnd($c4,$c4i);

    $hash->{CEL_CUBE} .= $c3->range( $of, pdl( $hash->{CEL_CUBE}->dims ) )->sever;

    
    print "Finding minima...";
    $hash->{CEL_CUBE} -= $c4->range($of, pdl($hash->{CEL_CUBE}->dims))->sever->mv(2,0)->minimum;
    
    return $hash;
}
    
