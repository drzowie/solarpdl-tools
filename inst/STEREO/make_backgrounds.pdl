=head2 make_backgrounds - generate minimum-value images for a data set

=for ref

make_backgrounds(\@files, \%opt);

=for ref

You feed in a list of file names and a background cadence in days, you
get back a set of background images made by taking the specified
percentile value from co-aligned stacks of images.

The following options are accepted:

=over 3

=item MASK_RADIUS (default undef)

if present, MASK_RADIUS sets the number of pixels, centered on the center of the image, that are valid -- everything outside that radius is set to zero.

=item RUNLENGTH (default 9)

This is the length, in days, of the interval to be used to create each minimum value image.

=item CADENCE (default RUNLENGTH/2)

This is the cadence with which background images are to be created, in days.  

=item PERCENTILE (default 2)

This is the percentile value of each pixel's lightcurve to accept as the
background. 

=item DECIMATION (default 2)

The number of horizontal and vertical tiles into which to break the input
(square this number to get the number of passes required for each background).

=item OUTDIR (default "BKGND")

The name of the output directory for the background images

=back

=cut
use Date::Parse;
use Date::Format;
use PDL::NiceSlice;

sub make_backgrounds {
    my $f = shift;
    my $opt = shift || {};

    my $defaults = {
	MASK_RADIUS => 0,
	CADENCE     => undef,
	RUNLENGTH   => 9,
	PERCENTILE  => 2,
	DECIMATION  => 3,
	OUTDIR      => "BKGND"
	};

    map { 
	$opt->{$_} = $defaults->{$_} unless(exists($opt->{$_})) 
	} keys %$defaults;

    unless(defined($opt->{CADENCE})) {
	$opt->{CADENCE} = $opt->{RUNLENGTH}/2;
    }


    ##############################
    print "Reading headers for ".(0+@$f)." files\n";
    unless(0+@hdrs){
    @hdrs = map { 
	print ".";
	rfits($_,{DATA=>0});
    } @$f;
    print "\n";
}
    ##############################
    print "Parsing times...\n";
    @times = map { str2time($_->{'DATE-AVG'} || $_->{'DATE-OBS'}); } @hdrs;
    $times = pdl(@times);

    ##############################
    # Check for monotonicity
    my $qsi = qsorti($times);
    unless(all($qsi==xvals($qsi))) {
	print "Hmmm,  some times seem to be out of order...\n";
    }

    my $limits = pdl($times->minmax);
    my $length = ($limits->((1))-$limits->((0)));
    my $center = ($limits->((1))+$limits->((0)))/2;

    print "Range spans $length seconds (".($length/24/3600)." days)\n";
    print "Center time is ".time2str("%Y-%m-%dT%T",$center)."\n";
    print "Start time is ".time2str("%Y-%m-%dT%T",$limits->at(0))."; end time is ".time2str("%Y-%m-%dT%T",$limits->at(1))."\n";
    
    my $l2 = $length/3600/24 - $opt->{RUNLENGTH};
    my $nsamp = int( $l2 / $opt->{CADENCE} )+1;
    
    print "There's room for $nsamp samples in the dataset...\n";
    
    $centers = (xvals($nsamp) - (($nsamp-1) * 0.5)) * $opt->{CADENCE} * 3600 * 24 
	+ $center;

    $starts = $centers - $opt->{RUNLENGTH}/2 * 3600 * 24;

    print "Start times are: ",join(", ", map { time2str("%Y-%m-%dT%T",$_) } $starts->list),"\n";

    print "Center times are :",join(", ", map { time2str("%Y-%m-%dT%T",$_) } ($starts+$opt->{RUNLENGTH}/2*3600*24)->list),"\n";

    my %processes = ();

    for $i(0..$starts->nelem - 1) {
	$begin = $starts->at($i);
	$end = $begin + $opt->{RUNLENGTH}*3600*24;
	
	@sampdex = which( ($times >= $begin) & ($times <= $end) )->list;
	@sampfiles = map { $f->[$_] } @sampdex;

	$out = zeroes(float, $hdrs[0]->{NAXIS1}, $hdrs[0]->{NAXIS2});
	$pass_w = int($hdrs[0]->{NAXIS1} / $opt->{DECIMATION});
	$pass_h = int($hdrs[0]->{NAXIS2} / $opt->{DECIMATION});

	@cdims = ($pass_w, $pass_h, 0+@sampfiles);

	print "Allocating a ",
	join("x",@cdims),
	" data cube... (",
	($pass_w * $pass_h * (0+@sampfiles) * 4/1024/1024/1024),
	 " GiB)\n";

	$cube = zeroes(float,@cdims);

	for $y(0..$opt->{DECIMATION}-1) {
	    for $x(0..$opt->{DECIMATION}-1) {
	
		print "x=$x; y=$y; i=$i.  Reading ".(0+@sampfiles)." files between ".time2str("%Y-%m-%dT%T",$begin)." and ".time2str("%Y-%m-%dT%T",$end)."\n";

		for $j(0..$#sampfiles) {
		    print ".";
		    $cube->(:,:,($j)) .= rfits($sampfiles[$j])
			->(
			   $x * $pass_w : $x * $pass_w + $cdims[0]-1,
			   $y * $pass_h : $y * $pass_h + $cdims[1]-1
			   );
		}
		print "\n";

	
		print "Sorting...";
		$cs = qsort($cube->mv(2,0));

		print "Finding $opt->{PERCENTILE} percentile...\n";
		$dex = int(0.5 + ($cs->dim(0) * $opt->{PERCENTILE}/100));
		$out->( $x * $pass_w : $x * $pass_w + $cdims[0]-1,
			$y * $pass_h : $y * $pass_h + $cdims[1]-1
			) .=$cs->(($dex));
	    }
	}
	$fname = sprintf("%s/BKG-%s.fits",$opt->{OUTDIR},time2str("%Y-%m-%dT%T",$centers->at($i)));
	print "Writing $fname...\n";
	wfits( $out, 
	       $fname
	       );
	       
    }

}
    
    
	    
	

