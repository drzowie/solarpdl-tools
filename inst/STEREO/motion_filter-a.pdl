=head2 motion_filter - hi2 pipeline component

=cut

sub motion_filter {
    my $hash = shift;
    my $opt = shift;

    $opt = {} unless defined($opt);

    $opt->{FILTER_SLOP}= 0.33           unless exists($opt->{FILTER_SLOP});
    $opt->{FILTER_APOD_FRAMES} = 3      unless exists($opt->{FILTER_APOD_FRAMES});
    $opt->{FILTER_APOD_MARGIN} = 10     unless exists($opt->{FILTER_APOD_MARGIN});
    $opt->{FILTER_MASK_TRIGGER} = 0.667 unless exists($opt->{FILTER_MASK_TRIGGER});

    my $of = pdl( $opt->{FILTER_APOD_MARGIN}, 
		   $opt->{FILTER_APOD_MARGIN}, 
		   $opt->{FILTER_APOD_FRAMES} );

    print "Apodizing...\n";
    $hash->{CEL_CUBE}->where($hash->{CEL_CUBE}->isbad) .= 0;
    for $i(0..$hash->{CEL_CUBE}->dim(2)-1) {
	my $m = ($hash->{CEL_CUBE}->(:,:,($i))->abs > $opt->{FILTER_MASK_TRIGGER})->convolveND(rvals(31,31)<=15);
	$hash->{CEL_CUBE}->(:,:,($i)) ->indexND( 0+whichND($m!=0)) .= 0;
    }
	

    my $c3 = $hash->{CEL_CUBE}->range( -$of,
				       2*$of + pdl( $hash->{CEL_CUBE}->dims ),
				       'm'
	)->sever;
    my $c3i = zeroes($c3);

    ## Now apodize the edges with a smooth rolloff...
    my $margin_rolloff = sin( 3.14159 / 2 / $opt->{FILTER_APOD_MARGIN} * xvals($opt->{FILTER_APOD_MARGIN}) );
    $margin_rolloff *= $margin_rolloff;

    $c3->(0:$opt->{FILTER_APOD_MARGIN}-1) *= $margin_rolloff;
    $c3->(-1:-$opt->{FILTER_APOD_MARGIN}:-1) *= $margin_rolloff;
    $c3->(:,0:$opt->{FILTER_APOD_MARGIN}-1)->mv(1,0) *= $margin_rolloff;
    $c3->(:,-1:-$opt->{FILTER_APOD_MARGIN}:-1)->mv(1,0) *= $margin_rolloff;

    my $frames_rolloff = sin( 3.14159 / 2 / $opt->{FILTER_APOD_FRAMES} * xvals($opt->{FILTER_APOD_FRAMES}) );
    $frames_rolloff *= $frames_rolloff;
    
    $c3->(:,:,0:$opt->{FILTER_APOD_FRAMES}-1)->mv(2,0) *= $frames_rolloff;
    $c3->(:,:,-1:-$opt->{FILTER_APOD_FRAMES}:-1)->mv(2,0) *= $frames_rolloff;

    my $filtslop = $opt->{FILTER_SLOP};
    my $filtfunc = sub {
        my $a = shift;
	my $b = shift;
	my $out = $a < $b * (1.0 - $filtslop);
	my $splice = ($a >= $b * (1.0 - $filtslop)) & ($a <= $b * (1.0 + $filtslop));
	my $hump = cos( (3.14159/2) * ($a - $b*(1.0-$filtslop))/(2*$b*$filtslop) );
	return( float($out) + ($hump * $hump * $splice));
    };

    
    print "FFT...";
    fftnd($c3, $c3i);
    
    print "filtering...";

    my $filt = ones(float,$c3->dims);
    my $cutoff = 1;
    my $nd = ndcoords($c3->(:,:,(0)));
    my $dims = pdl($c3->dim(0),$c3->dim(1));
    $nd -= pdl($dims) * ($nd > $dims/2);
    $nd /= ($dims/2);
    my $rv = ($nd*$nd)->sumover->sqrt;
    
    for $i(1..$c3->dim(2)/2) {
	$filtplane = &$filtfunc($rv, $i * $cutoff / $c3->dim(2)/2);
	$c3->(:,:,($i)) *= $filtplane;
	$c3i->(:,:,($i)) *= $filtplane;
	$c3->(:,:,(-$i)) *= $filtplane;
	$c3i->(:,:,(-$i)) *= $filtplane;
    }

    $c3->(:,:,(0)) .= 0;
    $c3i->(:,:,(0)) .= 0;


    # Cut out the middle of the $c3 FFT cube to make a reduced-resolution smoothed
    # cube (for smoothing)
    print "Copying...\n";
    $c4dims = pdl($c3->dims)/pdl(5,5,2);
    my $c4 = $c3 ->range(-$c4dims/2,$c4dims,'p')->range($c4dims/2,$c4dims,'p')->sever;
    my $c4i =$c3i->range(-$c4dims/2,$c4dims,'p')->range($c4dims/2,$c4dims,'p')->sever;
    
    print "inverse FFT (data)...";
    ifftnd($c3, $c3i);
    undef $c3i;
    $hash->{CEL_CUBE} .= $c3->range( $of, pdl( $hash->{CEL_CUBE}->dims ) )->sever;
    undef $c3;



    ##############################
    # Generate hypersmoothed data as a background.  

    print "Filtering...\n";

    $rv2d = rvals($c4dims->(0:1)->list, {center=>[($c4dims->(0:1)/2)->list]})->range($c4dims->(0:1)/2,$c4dims->(0:1),'p')->sever;

    $size = pdl($c3->dim(0)/50);
    $k2d = exp(-$rv2d*$rv2d / $size / $size);

    $size = $c4->dim(2)/10;

    $wcoord = xvals($c4->dim(2)) - $c4->dim(2) * (xvals($c4->dim(2))>$c4->dim(2)/2);
    for $i(1..$c4->dim(2)/2) {
	my $scale =  $k2d * exp(-$wcoord->at($i)*$wcoord->at($i)/$size/$size);
	$c4->(:,:,$i) *= $scale;
	$c4i->(:,:,$i) *= $scale;
	$c4->(:,:,-$i) *= $scale;
	$c4i->(:,:,-$i) *= $scale;
    }

    print "inverse FFT (smooth)...";
    ifftnd($c4,$c4i);
    $c4min = $c4->mv(2,0)->minimum->match($hash->{CEL_CUBE}->(:,:,(0)),{m=>'j'});

    
    print "Finding minima...";
    $hash->{CEL_CUBE} -= $c4->range($of, pdl($hash->{CEL_CUBE}->dims))->sever;
    print "returning from motion_filter...\n";
    return $hash;
}
    
