=head2 merge_batches - merge a dataset from the hi-2 pipeline

=for usage 

 merge_batches( \@files, \%opt );

=for ref

You feed in a collection of file names and an optional options hash, and the files are merged into a single set of FITS files in the destination directory ("merged" by default or set by the option "MERGED_DIR").

=cut
use Date::Format;

sub merge_batches {
    my $files = shift;
    my $opt = shift;
    
    $opt = {} unless defined($opt);
    $opt->{MERGED_DIR} = "L2" unless(defined $opt->{MERGED_DIR});
    $opt->{PROCESSES} = 8 unless(defined $opt->{PROCESSES});
    $opt->{MARGIN} = 20 unless(defined $opt->{MARGIN});    
    $opt->{START} = 0 unless(defined $opt->{START});
    $opt->{REGEXP} = 'clean\-(.*)\-\-BATCH.*' unless(defined $opt->{REGEXP});

    if($opt->{MERGED_DIR}  and  !(-d $opt->{MERGED_DIR})){
	`mkdir $opt->{MERGED_DIR}`;
    }

    my %filenames = ();
    
    print "Sorting ".(0+@$files)." files based on name...\n";

    for $file(@$files) {
	$f2 = $file;
	$f2 =~ s:.*/::;
	unless($f2 =~ m/$opt->{REGEXP}/) {
	    print "File $f2 doesn't match -- skipping\n";
	    next;
	} 
	$fdate = $1;
	print "fdate=$fdate\n";
	unless(exists($filenames{$fdate})){
	    $filenames{$fdate} = [];
	}
	
	push(@{$filenames{$fdate}}, $file);
    }

    # Now the filenames have been sorted.  Begin accumulating.

    my %pids = ();

    if($opt->{RENDER}) {
	$w=pgwin(dev=>"5/xs",size=>[4,4]);
	$w->close;
    }

    @k = sort keys %filenames;
    print "start is $opt->{START}; k is $#k\n";
    for $ii($opt->{START}..$#k) {

	$f = $k[$ii];

	next unless(@{$filenames{$f}} > 1);

    	while( (0 + keys %pids) >= $opt->{PROCESSES} ) {
	  $pid = wait();
	  if($pid<0) {
	      %pids = ();
	  }
	  if($opt->{RENDER}){
	      eval {$a=rfits($pids{$pid});};
	      if(defined($a)) {
		  $w=pgwin(dev=>"5/xs");
		  $w->imag($a,0,0.05);
		  $w->hold;
		  $w->text($a->hdr->{'DATE-AVG'},100,100);
		  $w->close;
	      }
	  }
	  delete $pids{$pid};
	}

	if((0 + keys %pids) < $opt->{PROCESSES}) {
	    $pid = fork();
	    if($pid<0) {
		die "fork failed\n";
	    } 
	    $mfname = sprintf("%s/merged-%s.fits",($opt->{MERGED_DIR} || "."),$f) ;
	    if($pid) {
		# parent
		$pids{$pid}=$mfname;
		print "Spawned task for $mfname\n";
	    } else {
		# daughter
		print "Evalling...\n";
		eval {
		    $ksiz = $opt->{MARGIN}*2 + 1;
		    my $k = (1 + cos(rvals($ksiz,$ksiz)*3.14159/$opt->{MARGIN})) 
			* (rvals($ksiz,$ksiz)<$opt->{MARGIN});
		    $k /= $k->sum;
		    
		    print "$f: ".(0+@{$filenames{$f}})." files...";
		    @cube = mrfits(@{$filenames{$f}});
		    my $cube = pdl(@cube)->mv(-1,0)->sever;
		    my $hdr = $cube[0]->gethdr;
		    undef @cube;
		    
		    $cube->where($cube->isbad) .= -100;
		    $badmask = (($cube <-1)->short | (!($cube->isfinite))->short);

		    # Expand the badmask so we can feather it later
		    for $i(0..$badmask->dim(0)-1) {
			print ",";
			$badmask->(($i)) .= $badmask->(($i))->convolveND(ones($ksiz*1.1,$ksiz*1.1),{method=>'direct'});
		    }
		    $mask= ($badmask==0)->float;

		    for $i(0..$mask->dim(0)-1) {
			print ".";
			$mask->(($i)) .= $mask->(($i))->convolveND($k);
		    }
		    
		    $avg = ($cube*$mask)->sumover / $mask->sumover;
		    
		    ##############################
		    # Add new header fields
		    $hdr->{COMMENT} .= "Background model removed; some stars and artifacts may remain\n";
		    $hdr->{HISTORY} .= "Removed background model (SwRI pipeline; PDL) CED\n   (Some artifacts may remain)";

		    $hdr->{DATE} = time2str("%Y-%m-%dT%H:%M:%S",time,'Z');
		    $hdr->{FILENAME} =~ s/_1(....\.fts)$/_2$1/;  # update L1 to L2

		    $avg->sethdr($hdr);
		    $fname = sprintf("%s/%s",($opt->{MERGED_DIR} || "."),$hdr->{FILENAME});
		    print "writing $fname\n";
		    wfits( $avg, $fname);
		};
		if($@){
			print STDERR "daughter: $@\n";
		}
		exit 0;
	    }
	} else {
	    print "Hmmm...\n";
	}
    }
    while(keys %pids) {
	$p = wait();
	return unless(defined($p) and $p>0);
	delete $pids{$p};
    }
}    
