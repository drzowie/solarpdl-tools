=pod

=head2 frag_tabulate
=for ref

Tabulate fragments in an associated set of frames

=for usage

$tabs = frag_tabulate(\@frag_id_list,\@images,{options});

The output is a hash ref containing a large pdl and several perl
variables about the data set.  The 'summary' field is a pdl indexed by
(fragment, frame, data type) and contains the flux, size, and centroid
x and y of each fragment in each frame, in that order.  
The 'frag_event' field contains the event list for each fragment.  The
'event' field contains the event list for the whole data set.

The IDs get crunched down to a set of consecutive integers.  The
assoc files are changed in place, so if the thing crashes you have to 
remake them, but at least it reduces the egregiousness of the disk waste.

=cut

sub frag_tabulate {
    my($opt,$id_list,$im_list) = find_opt(@_);
    local($_);
    
    ##############################
    ## Set up options
    $opt->{v_min} = 8         unless(defined $opt->{v_min});
    $opt->{t_min} = 4         unless(defined $opt->{t_min});
    $opt->{sz_min}= 4         unless(defined $opt->{sz_min});
    $opt->{keep}  = 0         unless(defined $opt->{keep});
    $opt->{tab} = $id_list    unless(defined $opt->{tab}); 
    #assoc files are set to change in place unless {tab} is defined
    
    $opt->{verbose} = 2 if($opt->{DEBUG});
    
    ##############################
    ## Allocate the fragments table
    
    my($maxfrag) = abs($id_list->[-1])->max;
    p $maxfrag,scalar(@{$id_list}),4,"\n";
    my($summary) = zeroes($maxfrag+1,scalar(@{$id_list}),4);
##summary is indexed by (fragment number, frame number, (flux, size, centroid x, centroid y)) 
   
    ##############################
    ## Ancillary indices for locus calculation
    my($xcoord) = xvals(abs($id_list->[-1])) ->flat;
    my($ycoord) = yvals(abs($id_list->[-1])) ->flat;
    my($icoord) = xvals(abs($id_list->[-1])->flat);
    my($loci)= [];
    
    ##############################
    ## Loop over frames and accumulate data.  To do event sorting-out, we have to
    ## lag that by one frame.
    my($fr);
    for $fr(0..$#{$im_list}){
	next unless (defined($im_list->[$fr]) && defined($id_list->[$fr]));
	
	print "(1) summarizing f$fr: \n" if($opt->{verbose});
	
	# Retrieve current images & find list of current fragments
	my($idmap) = abs($id_list->[$fr]);
	my($im) = $im_list->[$fr];
	my($ids) = $idmap->flat->long->uniq;
	
	print $ids->nelem," frags" if($opt->{verbose});
	
	my($floci) = {}; 
	
	# Loop over current fragments
	my($id);    
	my($n);
	
	for $id($ids->list) {
	    next unless $id;  # Skip the null case
	    
	    # Retrieve loci and cache them for later use.
	    my($xl,$yl,$il,$val) = where($xcoord, $ycoord, $icoord, $im->flat, $idmap->flat->long == $id);
	    
	    $floci->{ $id } = $il;
	    
	    my($flux)     = sumover($val);
	    my($size)     = $val->nelem;
	    
	    my($locus) = cat($xl,$yl);
	    my($centroid) = sumover($locus * $val) / $flux;
	    
	    $summary->(($id),($fr),:) .= $flux->append($size)->append($centroid);
	    
	    print "$fr,$id: ",$summary->(($id),($fr),:),", ",$flux->append($size)->append($centroid),"\n"
		if($opt->{verbose}>2);
	    print "." if($opt->{verbose} && (($n++ % 10 == 0) || $opt->{verbose}>1));
	    
	}
##end loop over ids in a frame 
=pod
=begin comment
 Cache locus information for later.  This deserves a little more explanation: $loci is an array (indexed by frame) whose elements are hashes.  The keys of the hash are the unique ids in that frame, and the values are the flattened image pixel numbers that contain the id for that frame.  So to get all the pixels that have id of 16 in frame 10, one would say $loci->[10]->{16}.  Remember that while the frames are continuously indexed (0,1,2,3,...), the hash keys for a given frame won't be: {0,4,5,8,9,13,...}
=end comment
=cut

	$loci->[$fr] = $floci;
	
	print "\n" if($opt->{verbose});
    }
##end loop over frames    
    
    ##############################
    ## Filter on volume and other criteria, and crunch IDs.

    print "Filtering fragments: volume..." if($opt->{verbose});
    my($frag_ok) = ($summary->(:,:,(1))->xchg(0,1)->sumover > $opt->{v_min});
    
    print "time..." if($opt->{verbose});
    $frag_ok &= (($summary->(:,:,(1))->xchg(0,1) != 0)->sumover) > $opt->{t_min};
    
    print "size..." if($opt->{verbose});
    $frag_ok &= ($summary->(:,:,(1))->xchg(0,1)->maximum > $opt->{sz_min});
    
    print "ok\n" if($opt->{verbose});

    my($ok_id) = which ($frag_ok);
##note that anything based on which($frag_ok) is only going to have positive ID numbers!

## IF a concentration is going to get discarded
## AND it is touching another concentration of the same sign
## THEN reassociate the small concentration with the bigger one
## THEN redo the statistics of the new,larger,concentration

    my $reassoc = 0;
    my $frag_recon = !$frag_ok;
    my $ids_recon = which($frag_recon); 
    print "reconsidering",$ids_recon->nelem,"ids.\n" if $opt->{verbose};
    my $loci_recon=[];
    my $xsize=$im_list->[0]->dim(0);
    my ($xmin,$xmax,$ymin,$ymax,$pixarray,$sizes);
   
##something is happening when it's incrementing frames that causes it to really slow down at the point--it's nice and quick within each frame loop.

    for my $fr(0..$#{$im_list})
    {
	print "frame: $fr\n";
	next unless (defined($im_list->[$fr]) && defined($id_list->[$fr]));

	for my $id($ids_recon->list)
	{
	    next unless any(pdl(keys %{$loci->[$fr]})==$id);
            ##the id to be reconsidered actually exists in this frame
	    print "Reconsidering id: $id\n" if $opt->{verbose};
            ##set up a bounding box
	    ($xmin,$xmax)=minmax($loci->[$fr]->{$id}->pdl % $xsize);
	    ($ymin,$ymax)=minmax(floor($loci->[$fr]->{$id}->pdl / $xsize));
	    my $subfield=$id_list->[$fr]->range([$xmin-1,$ymin-1],[$xmax-$xmin+2,$ymax-$ymin+2],'t');
            ##find out what other ids are in this subfield
	    my $idsub=$subfield->uniq;
	    $sizes=zeroes($idsub);
	    ##just loop over those

	    for my $id_ok($idsub->list){
		next unless $id_ok; ##don't do the zero background
		next unless any($ok_id == $id_ok); 
                ##sorry about the names--only consider it if it's not discarded itself
                ##this also prevents the trivial case.
		next unless (sign($summary($id_ok,$fr,(0)))==sign($summary($id,$fr,(0)))); ##only reassociate if it's the same sign
		$pixarray=zeroes($subfield->dims,4);
                ##set pixarray = 1 where the reconsidered id is
		my ($xok,$yok)=whichND($subfield->abs==$id);
		my $xyok=cat($xok,$yok)->mv(-1,0);
		$pixarray->indexND($xyok).=1;
##increment pixarray by 1 where the ok id is, but offset by 1 in each direction
		my ($xid,$yid)=whichND($subfield==$id_ok);
		my $xyid=cat($xid,$yid,pdl(0))->mv(-1,0);
		$pixarray->indexND($xyid+pdl(1,0,0),'t')+=1;
		$pixarray->indexND($xyid+pdl(-1,0,1),'t')+=1;
		$pixarray->indexND($xyid+pdl(0,1,2),'t')+=1;
		$pixarray->indexND($xyid+pdl(0,-1,3),'t')+=1;

                ##if these ids touch, pixarray will be two somewhere
		if (any($pixarray>1)){
		    $sizes(which($idsub==$id_ok)).=$summary($id_ok,$fr,(1));
		}
	    }
            ##end loop over alread ok ids to match to
            ##reassociate it with the largest one that it touches
	    if (any($sizes))
	    {
		my $idreassoc=$idsub(which($sizes==$sizes->max)->(0)); ##->(0) just in case two of same size
		$idreassoc=$idreassoc->((0));
##for some reason that doesn't need to be done with $id, but it's necessary here for accessing the keys of the $loci hashes

		$loci->[$fr]->{$idreassoc}=$loci->[$fr]->{$idreassoc}->append($loci->[$fr]->{$id});
		$summary(($idreassoc),($fr),(0))+=$summary(($id),($fr),(0));
		$summary(($idreassoc),($fr),(1))+=$summary(($id),($fr),(1));

## redo the center of gravity calculation
		my $locus=cat($loci->[$fr]->{$idreassoc}%$xsize,floor($loci->[$fr]->{$idreassoc}/$xsize));
	       #$locus+=pdl(($xmin),($ymin))->transpose;
		my $val=index($im_list->[$fr]->flat,$loci->[$fr]->{$idreassoc});
#		p "val dims",join("x",$val->dims),", locus dims",join("x",$locus->dims),"\n";

		my $centroid=sumover($locus*$val)/$summary(($idreassoc),($fr),(0));
		$summary(($idreassoc),($fr),(2)).=$centroid((0));
		$summary(($idreassoc),($fr),(3)).=$centroid((1));

		print "found",++$reassoc,"to reassociate\n" if $opt->{verbose};
	    }
	    elsif ($opt->{keep}){
		print "Keeping $id anyway\n" if $opt->{verbose};
		$frag_ok($id).=1;
	    }

	}##end loop over reconsidered ids

    }##end loop over frames

##need to remake this because we might have (if $opt->{keep}) re-ok'd some features
    $ok_id = which($frag_ok);

    # Generate forward and backward conversions for IDs.  The +1s are to 
    # make the new IDs starts at 1 not 0.
    my($a,$id_conv);
    for $a(0..$ok_id->nelem-1) {
	$id_conv->{$ok_id->at($a)} = $a+1;
    }
    my($newids) = xvals($ok_id)+1;
    
    # Compress all the IDs in the images.
    for $fr(0..$#{$im_list}) {
	print "(2) crunching f$fr: " if($opt->{verbose});
	my $idmap = zeroes(abs($id_list->[0]));
	$floci = $loci->[$fr];
	
	print scalar(keys %{$floci}),"ids, of which",sum($frag_ok->(pdl(keys %{$floci})))," are OK " if($opt->{verbose});
	
	my($n) = 0;
	for $old_id(keys %{$floci}) {
	    next unless $id_conv->{$old_id};
	    $idmap->flat->($floci->{$old_id}) .= $id_conv->{$old_id};
	    print "." if($opt->{verbose} && (($n++ % 10 == 0) || $opt->{verbose}>1));
	}
	
	$opt->{tab}->[$fr] = $idmap;
	print "\n" if($opt->{verbose});
    }
    print "Copying summary...\n";
    my($sum2) = $summary->(append(pdl(0),$ok_id),:,:)->copy;
    print "cleaning up...\n";
    undef $summary;
    print "$reassoc concentrations reassociated\n";
    print "frag_tabulate completed successfully.\n";
    return $sum2;
}
