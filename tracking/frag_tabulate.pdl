=pod

=head2 frag_tabulate

=for ref

Tabulate features in an associated set of frames

=for usage

$tabs = frag_tabulate(\@frag_id_list,\@images,{options});

The output is a hash ref containing a large pdl and several perl
variables about the data set.  The 'summary' field is a pdl indexed by
(feature, frame, data type) and contains the flux, size, and centroid
x and y of each feature in each frame, in that order.  

The IDs get crunched down to a set of consecutive integers.  The
assoc files can be changed in place (see option 'tab'), so if the thing 
crashes you have to remake them, but at least it reduces the egregiousness 
of the disk waste.

OPTIONS

=over 3

=item v_min (default 8)

A feature with a total volume (total number of pixels in the x-y-t sense) 
smaller than this value will get filtered as noise.

=item t_min (default 4)

A feature with a lifetime (in frames) smaller than this value will get 
filtered as noise.

=item sz_min (default 4)

A feature with a maximum size smaller than this value will get filtered as 
noise.

=item keep (default 0)

In order to prevent filtering causing the C<Swiss cheese problem>, features
that are going to get discarded that are touching another feature of the 
same sign will be reassociated to that feature.  Features that do not touch
 another same-sign feature will be discarded.  Set this option to 1 to 
prevent the discarding.  Reassociation happens whether you want it or not.

=item tab

Set this option to an array ref or DiskCache object to prevent the assoc 
files from being changed in place.

=item verbose

Chat.

=back

BUGS

If the largest id number isn't alive in the last frame, then summary won't get initialized big enough. (22-June-2005)

HISTORY

Craig DeForest ??? wrote most of it.

Derek Lamb 15-Nov-2004 added reassociation to fix the swiss cheese problem.

Derek Lamb 02-Jun-2005 added documentation.

=cut

use strict;
use PDL::NiceSlice;

sub frag_tabulate {
    my($opt,$id_list,$im_list) = find_opt(@_);
    local($_);
    
    ##############################
    ## Set up options
    $opt->{v_min} = 8         unless(defined $opt->{v_min});
    $opt->{t_min} = 4         unless(defined $opt->{t_min});
    $opt->{sz_min}= 4         unless(defined $opt->{sz_min});
    $opt->{keep}  = 0         unless(defined $opt->{keep});
    $opt->{tab} = $id_list    unless(defined $opt->{tab}); 
    #assoc files are set to change in place unless {tab} is defined
    
    $opt->{verbose} = 2 if($opt->{DEBUG});
    
    ##############################
    ## Allocate the features table
    
    my($maxfrag) = abs($id_list->[-1])->max;  
    my($summary) = zeroes($maxfrag+1,scalar(@{$id_list}),4);
##summary is indexed by (feature number, frame number, (flux, size, centroid x, centroid y)) 
   
    ##############################
    ## Ancillary indices for locus calculation
    my($xcoord) = xvals(abs($id_list->[-1])) ->flat;
    my($ycoord) = yvals(abs($id_list->[-1])) ->flat;
    my($icoord) = xvals(abs($id_list->[-1])->flat);
    my($loci)= [];
    
    ##############################
    ## Loop over frames and accumulate data.

    my($fr);
    for $fr(0..$#{$im_list}){
	next unless (defined($im_list->[$fr]) && defined($id_list->[$fr]));
	
	print "(1) summarizing f$fr: \n" if($opt->{verbose});
	
	# Retrieve current images & find list of current features
	my($idmap) = abs($id_list->[$fr]);
	my($im) = $im_list->[$fr];
	my($ids) = $idmap->flat->long->uniq;
	
	print $ids->nelem," frags" if($opt->{verbose});
	
	my($floci) = {}; 
	
	# Loop over current features
	my($id);    
	my($n);
	
	for $id($ids->list) {
	    next unless $id;  # Skip the null case

   	    # Retrieve loci and cache them for later use.
	    my($xl,$yl,$il,$val) = where($xcoord, $ycoord, $icoord, $im->flat, $idmap->flat->long == $id);
	    
	    $floci->{ $id } = $il;
	    
	    my($flux)     = sumover($val);
	    my($size)     = $val->nelem;
	    
	    my($locus) = cat($xl,$yl);
	    my($centroid) = sumover($locus * $val) / $flux;
	    
##put in a check: if id is bigger than maxfrag, then we need to append a slice to summary. This is an issue if the largest id number in the data set isn't alive in the last frame (i.e., very rarely).
	    
	    $summary=$summary->append(zeroes(1,scalar(@{$id_list}),4)) if ($id>$maxfrag);
	    $summary->(($id),($fr),:) .= $flux->append($size)->append($centroid);
	    
	    print "$fr,$id: ",$summary->(($id),($fr),:),", ",$flux->append($size)->append($centroid),"\n"
		if($opt->{verbose}>2);
	    print "." if($opt->{verbose} && (($n++ % 10 == 0) || $opt->{verbose}>1));
	    
	}
##end loop over ids in a frame 
=pod
=begin comment
 Cache locus information for later.  This deserves a little more explanation: 
$loci is an array (indexed by frame) whose elements are hashes.  The keys of 
the hash are the unique ids in that frame, and the values are the flattened 
image pixel numbers that contain the id for that frame.  So to get all the 
pixels that have id of 16 in frame 10, one would say $loci->[10]->{16}.  
Remember that while the frames are continuously indexed (0,1,2,3,...), the 
hash keys for a given frame won't be: {0,4,5,8,9,13,...}
=end comment
=cut

	$loci->[$fr] = $floci;
	
	print "\n" if($opt->{verbose});
    }
##end loop over frames    
    
    ##############################
    ## Filter on volume and other criteria, and crunch IDs.

    print "Filtering features: volume..." if($opt->{verbose});
    my($frag_ok) = ($summary->(:,:,(1))->xchg(0,1)->sumover >= $opt->{v_min});
    
    print "time..." if($opt->{verbose});
    $frag_ok &= (($summary->(:,:,(1))->xchg(0,1) != 0)->sumover) >= $opt->{t_min};
    
    print "size..." if($opt->{verbose});
    $frag_ok &= ($summary->(:,:,(1))->xchg(0,1)->maximum >= $opt->{sz_min});
    
    print "ok\n" if($opt->{verbose});

    my($ok_id) = which ($frag_ok);
##note that anything based on which($frag_ok) is only going to have positive ID numbers!

## IF a concentration is going to get discarded
## AND it is touching another concentration of the same sign
## THEN reassociate the small concentration with the bigger one
## THEN redo the statistics of the new,larger,concentration

    my $reassoc = 0;
    my $frag_recon = !$frag_ok;
    my $ids_recon = which($frag_recon); 
    print "reconsidering",$ids_recon->nelem,"ids.\n" if $opt->{verbose};
    my $loci_recon=[];
    my $xsize=$im_list->[0]->dim(0);
    my ($xmin,$xmax,$ymin,$ymax,$pixarray,$sizes);
   
##something is happening when it's incrementing frames that causes it to really slow down at the point--it's nice and quick within each frame loop.
##try defining some more things as 'my' outside the loop so there's less garbage collection.
    my ($subfield,$idsub,$xok,$yok,$xyok,$xid,$yid,$xyid);
    for my $fr(0..$#{$im_list})
    {
	print "frame: $fr\n";
	next unless (defined($im_list->[$fr]) && defined($id_list->[$fr]));

	for my $id($ids_recon->list)
	{
	    next unless any(pdl(keys %{$loci->[$fr]})==$id);
            ##the id to be reconsidered actually exists in this frame
	    print "Reconsidering id: $id\n" if $opt->{verbose};
            ##set up a bounding box
	    ($xmin,$xmax)=minmax($loci->[$fr]->{$id}->pdl % $xsize);
	    ($ymin,$ymax)=minmax(floor($loci->[$fr]->{$id}->pdl / $xsize));
	    $subfield=$id_list->[$fr]->range([$xmin-1,$ymin-1],[$xmax-$xmin+2,$ymax-$ymin+2],'t');
            ##find out what other ids are in this subfield
	    $idsub=$subfield->uniq;
	    $sizes=zeroes($idsub);
	    ##just loop over those

	    for my $id_ok($idsub->list){
		next unless $id_ok; ##don't do the zero background
		next unless any($ok_id == $id_ok); 
                ##sorry about the names--only consider it if it's not discarded itself
                ##this also prevents the trivial case.
		next unless (sign($summary($id_ok,$fr,(0)))==sign($summary($id,$fr,(0)))); ##only reassociate if it's the same sign
		$pixarray=zeroes($subfield->dims,4);
                ##set pixarray = 1 where the reconsidered id is
		($xok,$yok)=whichND($subfield->abs==$id);
		$xyok=cat($xok,$yok)->mv(-1,0);
		$pixarray->indexND($xyok).=1;
##increment pixarray by 1 where the ok id is, but offset by 1 in each direction
		($xid,$yid)=whichND($subfield==$id_ok);
		$xyid=cat($xid,$yid,pdl(0))->mv(-1,0);
		$pixarray->indexND($xyid+pdl(1,0,0),'t')+=1;
		$pixarray->indexND($xyid+pdl(-1,0,1),'t')+=1;
		$pixarray->indexND($xyid+pdl(0,1,2),'t')+=1;
		$pixarray->indexND($xyid+pdl(0,-1,3),'t')+=1;

                ##if these ids touch, pixarray will be two somewhere
		if (any($pixarray>1)){
		    $sizes(which($idsub==$id_ok)).=$summary($id_ok,$fr,(1));
		}
	    }
            ##end loop over already ok ids to match to
            ##reassociate it with the largest one that it touches
	    if (any($sizes))
	    {
	        my $idreassoc=$idsub(which($sizes==$sizes->max)->(0)); ##->(0) just in case two of same size
		$idreassoc=$idreassoc->((0));
##for some reason that doesn't need to be done with $id, but it's necessary here for accessing the keys of the $loci hashes

		$loci->[$fr]->{$idreassoc}=$loci->[$fr]->{$idreassoc}->append($loci->[$fr]->{$id});
		$summary(($idreassoc),($fr),(0))+=$summary(($id),($fr),(0));
		$summary(($idreassoc),($fr),(1))+=$summary(($id),($fr),(1));

## redo the center of gravity calculation
		my $locus=cat($loci->[$fr]->{$idreassoc}%$xsize,floor($loci->[$fr]->{$idreassoc}/$xsize));
	       
		my $val=index($im_list->[$fr]->flat,$loci->[$fr]->{$idreassoc});

		my $centroid=sumover($locus*$val)/$summary(($idreassoc),($fr),(0));
		$summary(($idreassoc),($fr),(2)).=$centroid((0));
		$summary(($idreassoc),($fr),(3)).=$centroid((1));

		$reassoc++;
		print "found",$reassoc,"to reassociate\n" if $opt->{verbose};
	    }
	    elsif ($opt->{keep}){
		print "Keeping $id anyway\n" if $opt->{verbose};
		$frag_ok($id).=1;
	    }

	}##end loop over reconsidered ids

    }##end loop over frames

##need to remake this because we might have (if $opt->{keep}) re-ok'd some features
    $ok_id = which($frag_ok);

    # Generate forward and backward conversions for IDs.  The +1s are to 
    # make the new IDs starts at 1 not 0.
    my($a,$id_conv);
    for $a(0..$ok_id->nelem-1) {
	$id_conv->{$ok_id->at($a)} = $a+1;
    }
    my($newids) = xvals($ok_id)+1;
    
    # Compress all the IDs in the images.
    for $fr(0..$#{$im_list}) {
	print "(2) crunching f$fr: " if($opt->{verbose});
	my $idmap = zeroes(abs($id_list->[0]));
	my $floci = $loci->[$fr];
	
	print scalar(keys %{$floci}),"ids, of which",sum($frag_ok->(pdl(keys %{$floci})))," are OK " if($opt->{verbose});
	
	my($n) = 0;
	for my $old_id(keys %{$floci}) {
	    next unless $id_conv->{$old_id};
	    $idmap->flat->($floci->{$old_id}) .= $id_conv->{$old_id};
	    print "." if($opt->{verbose} && (($n++ % 10 == 0) || $opt->{verbose}>1));
	}
	
	$opt->{tab}->[$fr] = $idmap;
	print "\n" if($opt->{verbose});
    }
    print "Copying summary...\n";
    my($sum2) = $summary->(append(pdl(0),$ok_id),:,:)->copy;
    print "cleaning up...\n";
    undef $summary;
    print "$reassoc concentrations reassociated\n";
    print "frag_tabulate completed successfully.\n";
    return $sum2;
}
