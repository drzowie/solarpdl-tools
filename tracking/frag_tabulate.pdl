=head2 frag_tabulate
=for ref

Tabulate fragments in an associated set of frames

=for usage

$tabs = frag_tabulate(\@frag_id_list,\@images,{options});

The output is a hash ref containing a large pdl and several perl
variables about the data set.  The 'summary' field is a pdl indexed by
(fragment, frame, data type) and contains the flux, size, and centroid
x and y of each fragment in each frame, in that order.  
The 'frag_event' field contains the event list for each fragment.  The
'event' field contains the event list for the whole data set.

The IDs get crunched down to a set of consecutive integers.  The
assoc files are changed in place, so if the thing crashes you have to 
remake them, but at least it reduces the egregiousness of the disk waste.

=cut

sub frag_tabulate {
    my($opt,$id_list,$im_list) = find_opt(@_);
    local($_);
    
    ##############################
    ## Set up options
    $opt->{v_min} = 8         unless(defined $opt->{v_min});
    $opt->{t_min} = 4         unless(defined $opt->{t_min});
    $opt->{sz_min}= 4         unless(defined $opt->{sz_min});
    
    $opt->{tab} = $id_list    unless(defined $opt->{tab}); 
    #assoc files are set to change in place unless {tab} is defined
    
    ##none of this r stuff is used anywhere;
    ##a relic from when the history info was produced here?
    $opt->{r} = 2                 unless(defined $opt->{r});
    $opt->{r_em}    = $opt->{r}   unless(defined $opt->{r_em});
    $opt->{r_sub}   = $opt->{r}   unless(defined $opt->{r_sub});
    $opt->{r_merge} = $opt->{r}   unless(defined $opt->{r_merge});
    $opt->{r_frag}  = $opt->{r}   unless(defined $opt->{r_frag});
    #####
    
    $opt->{verbose} = 2 if($opt->{DEBUG});
    
    ##############################
    ## Allocate the fragments table
    for ($k=-1;!defined($id_list->[$k]);$k--){;}
    ##do this to find the last defined image in $id_list
    ##may not be necessary if frag_assoc completed successfully
    
    my($maxfrag) = abs($id_list->[$k])->max;
    print "k: $k\n";
    p $maxfrag,scalar(@{$id_list}),4,"\n";
    my($summary) = zeroes($maxfrag+1,scalar(@{$id_list}),4);
##summary is indexed by (fragment number, frame number, (flux, size, centroid x, centroid y)) 
   
    ##############################
    ## Ancillary indices for locus calculation
    my($xcoord) = xvals(abs($id_list->[$k])) ->flat;
    my($ycoord) = yvals(abs($id_list->[$k])) ->flat;
    my($icoord) = xvals(abs($id_list->[$k])->flat);
    my($loci)= [];
    
    ##############################
    ## Loop over frames and accumulate data.  To do event sorting-out, we have to
    ## lag that by one frame.
    my($fr);
    for $fr(0..$#{$im_list}){
	next unless (defined($im_list->[$fr]) && defined($id_list->[$fr]));
	
	print "(1) summarizing f$fr: \n" if($opt->{verbose});
	
	# Retrieve current images & find list of current fragments
	my($idmap) = abs($id_list->[$fr]);
	my($im) = $im_list->[$fr];
	my($ids) = $idmap->flat->long->uniq;
	
	print $ids->nelem," frags" if($opt->{verbose});
	
	my($floci) = {}; 
	
	# Loop over current fragments
	my($id);    
	my($n);
	
	for $id($ids->list) {
	    next unless $id;  # Skip the null case
	    
	    # Retrieve loci and cache them for later use.
	    my($xl,$yl,$il,$val) = where($xcoord, $ycoord, $icoord, $im->flat, $idmap->flat->long == $id);
	    
	    $floci->{ $id } = $il;
	    
	    my($flux)     = sumover($val);
	    my($size)     = $val->nelem;
	    
	    my($locus) = cat($xl,$yl);
	    my($centroid) = sumover($locus * $val) / $flux;
	    
	    $summary->(($id),($fr),:) .= $flux->append($size)->append($centroid);
	    
	    print "$fr,$id: ",$summary->(($id),($fr),:),", ",$flux->append($size)->append($centroid),"\n"
		if($opt->{verbose}>2);
	    print "." if($opt->{verbose} && (($n++ % 10 == 0) || $opt->{verbose}>1));
	    
	}
##end loop over ids in a frame 
	
	# Cache locus information for later.  This deserves a little more explanation: 
        #$loci is an array (indexed by frame) whose elements are hashes. 
        #The keys of the hash are the unique ids in that frame, and the values
        #are the flattened image pixel numbers that contain the id for that frame.
        #So to get all the pixels that have id of 16 in frame 10, one would say $loci->[10]->{16}.
        #Remember that while the frames are continuously indexed (0,1,2,3,...),
        #the hash keys for a given frame won't be: {0,4,5,8,9,13,...}

	$loci->[$fr] = $floci;
	
	print "\n" if($opt->{verbose});
    }
##end loop over frames    
    
    ##############################
    ## Filter on volume and other criteria, and crunch IDs.
    
    print "Filtering fragments: volume..." if($opt->{verbose});
    my($frag_ok) = ($summary->(:,:,(1))->xchg(0,1)->sumover > $opt->{v_min});
    
    print "time..." if($opt->{verbose});
    $frag_ok &= (($summary->(:,:,(1))->xchg(0,1) != 0)->sumover) > $opt->{t_min};
    
    print "size..." if($opt->{verbose});
    $frag_ok &= ($summary->(:,:,(1))->xchg(0,1)->maximum > $opt->{sz_min});
    
    print "ok\n" if($opt->{verbose});

    my($ok_id) = which ($frag_ok);

=begin comment
something is wrong with $idreassoc, but it will have to wait until later
## IF a concentration is going to get discarded
## AND it is touching another concentration of the same sign
## THEN reassociate the small concentration with the bigger one
## THEN redo the statistics of the new,larger,concentration
    my $print=1;
    my $reassoc = 0;
    my $frag_recon = !$frag_ok;
    my $ids_recon = which($frag_recon);
    print "reconsidering",$ids_recon->nelem,"ids.\n" if $opt->{verbose};
    my $loci_recon=[];
    my $xsize=$im_list->[0]->dim(0);
    my ($xmin,$xmax,$ymin,$ymax,$pixarray,$sizes);
    for my $fr(0..$#{$im_list})
    {
	print "frame: $fr\n";
	next unless (defined($im_list->[$fr]) && defined($id_list->[$fr]));
	for my $id($ids_recon->list)
	{
	    next unless any(pdl(keys %{$loci->[$fr]})==$id);
            ##the id to be reconsidered actually exists in this frame
            ##set up a bounding box
	    p "got 0\t" if $print;
	    ($xmin,$xmax)=minmax($loci->[$fr]->{$id}->pdl % $xsize);
	    ($ymin,$ymax)=minmax(floor($loci->[$fr]->{$id}->pdl / $xsize));
	    p "1\t" if $print;
	    $subfield=$id_list->[$fr]->range([$xmin-1,$ymin-1],[$xmax-$xmin+2,$ymax-$ymin+2],'t');
	    p "2\t" if $print;
            ##find out what other ids are in this subfield
	    $idsub=$subfield->uniq;
	    $sizes=zeroes($idsub);
	    p "3\t" if $print; 
	    ##just loop over those
	    for my $id_ok($idsub->list){
		p "3a\t" if $print;
		next unless $id_ok; ##don't do the zero background
		p "3b\t" if $print;
		next unless any($ok_id == $id_ok); 
                ##sorry about the names--only consider it if it's not discarded itself
                ##this also prevents the trivial case.
		p "3c\t" if $print;
		next unless (sign(pdl($id_ok))==sign(pdl($id))); ##only reassociate if it's the same sign
		p "4\t" if $print;
		$pixarray=zeroes($subfield->dims,4);
                ##set pixarray = 1 where the reconsidered id is
		($xok,$yok)=whichND($subfield==$id);
		$xyok=cat($x,$y)->mv(-1,0);
		$pixarray->indexND($xyok).=1;
		p "5\t" if $print;
##increment pixarray by 1 where the ok id is, but offset by 1 in each direction
		($xid,$yid)=whichND($subfield==$id_ok);
		$xyid=cat($xid,$yid,pdl(0))->mv(-1,0);
		$pixarray->indexND($xyid+pdl(1,0,0),'t')+=1;
		$pixarray->indexND($xyid+pdl(-1,0,1),'t')+=1;
		$pixarray->indexND($xyid+pdl(0,1,2),'t')+=1;
		$pixarray->indexND($xyid+pdl(0,-1,3),'t')+=1;

		p "6\t" if $print;
                ##if these ids touch, pixarray will be two somewhere
		if (any($pixarray>1)){
		    $sizes(which($idsub==$id_ok)).=$summary($id_ok,$fr,(1));
		}
	    }
            ##end loop over alread ok ids to match to
            ##reassociate it with the largest one that it touches
	    p "7\t" if $print;
	    if (any($sizes)){
		$idreassoc=$idsub(which($sizes==$sizes->max)->(0)); ##->(0) just in case two of same size
		p "8\t" if $print;
		p "idreassoc:$idreassoc\n" if $print;
		p "id:$id\n" if $print;
		p "loci fr id:",$loci->[$fr]->{$id},"\n" if $print;
		p "loci fr idreassoc",$loci->[$fr]->{$idreassoc},"\n" if $print;
		$loci->[$fr]->{$idreassoc}=$loci->[$fr]->{$idreassoc}->append($loci->[$fr]->{$id});
		$summary(($idreassoc),($fr),(0))+=$summary(($id),($fr),(0));
		$summary(($idreassoc),($fr),(1))+=$summary(($id),($fr),(1));
		print "found",++$reassoc,"to reassociate\n" if $opt->{verbose};
		$print=0;
	    }
	}##end loop over reconsidered ids

    }##end loop over frames
=end comment
=cut

    # Generate forward and backward conversions for IDs.  The +1s are to 
    # make the new IDs starts at 1 not 0.
    my($a,$id_conv);
    for $a(0..$ok_id->nelem-1) {
	$id_conv->{$ok_id->at($a)} = $a+1;
    }
    my($newids) = xvals($ok_id)+1;
    
    # Compress all the IDs in the images.
    for $fr(0..$#{$im_list}) {
	print "(2) crunching f$fr: " if($opt->{verbose});
	$idmap = zeroes(abs($id_list->[0]));
	$floci = $loci->[$fr];
	
	print scalar(keys %{$floci}),"ids, of which",sum($frag_ok->(pdl(keys %{$floci})))," are OK " if($opt->{verbose});
	
	my($n) = 0;
	for $old_id(keys %{$floci}) {
	    next unless $id_conv->{$old_id};
	    $idmap->flat->($floci->{$old_id}) .= $id_conv->{$old_id};
	    print "." if($opt->{verbose} && (($n++ % 10 == 0) || $opt->{verbose}>1));
	}
	
	$opt->{tab}->[$fr] = $idmap;
	print "\n" if($opt->{verbose});
    }
    print "Copying summary...\n";
    my($sum2) = $summary->(append(pdl(0),$ok_id),:,:)->copy;
    print "cleaning up...\n";
    undef $summary;
    print "$reassoc concentrations reassociated\n";
    print "frag_tabulate completed successfully.\n";
    return $sum2;
}
