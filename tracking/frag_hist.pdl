=pod

=head2 frag_hist

=for ref

Generate history for fragment ids.

=for usage

$hist = frag_hist($frag_detail, $frag_ids, { options })

$frag_detail is the output from frag_tabulate. This will be a list
of unique ids with information on flux, size, and position.
$frag_ids is the frag id of each pixel. This will be regularized by
frag_tabulate.

$hist gets an Nx11 PDL that lists fragment history versus ID (which is
used as an index).  For each fragment, the elements are:

=over 3

=item 0: birth frame

=item 1: birth method (see METHODS below)

=item 2: birth associated ID (see below)

=item 3: death frame

=item 4: death method (see METHODS below)

=item 5: death associated ID (see below)

=item 6: lifetime (in frames for now)

=item 7: birth location (X)

=item 8: birth location (Y)

=item 9: death location (X)

=item 10: death location (Y)

=back

METHODS

These are:

=item -1: UNKNOWN OR ERROR

The fragment didn't fit any particular pattern.  (For example, it is near
enough other fragments to be interacting with them, but the interaction
doesn't even approximate flux conservation).

n=item 0: SURVIVAL

The fragment was born before, or survived past, the last frame

=item 1: COALESCENCE/DISSIPATION

The fragment appeared "out of the blue", or disappeared mysteriously.

=item 2: EMERGENCE/CANCELLATION

The fragment was born associated with a recently-born opposing flux
concentration, or with a growing opposing flux concentration; or 
died associated with a recently-died opposing flux concentration or
with a shrinking opposing flux concentration.

=item 3: FRAGMENTATION/MERGER

The fragment broke off of another similar-signed fragment; or 
died by glomming onto a same-sign concentration.

=item 4: COMPLEX

The fragment fits both 1 and 3.

=back

OPTIONS

=over 3

=item a,b (default 1,4)

radius for consideration for determining neighbours, measured in
pixels. radius is given (a+br) where a and b are variable coefficients
and r is one pixel.  'a' sets a minimum size for consideration; 'b' is
an effective maximum eccentricity to consider -- e.g. b=1 only works
if all fragments are circular, b=5 can work for fragments up to 5x
longer than wide (but at a speed cost).  

Fragments that are too eccentric don't get properly considered.
=item sep (default 3)

Maximum separation between two fragments for them to be considered 
to be interacting.  Measured in pixels.

=item ratio (default 0.75) 

The relative loss required in an associated fragment for a new fragment to be
consistent with emergence and/or fragmentation.  Setting this to 0 requires
only that the flux differential be in the correct direction, neglecting 
its magnitude.  Setting it to a negative number allows nonconservative
solutions. 

=item pre (default 1)

Number of frames before an event in which to look for a complimentary event.

=item post (default 1)

Number of frames after an event in which to look for a complimentary event.

=back

BUGS

The only death event that is currently accurately measured is (none).

HISTORY

Alisdair Davey 05/10/04 Removed fragment history code from frag_hist
                        and moved to here. 

Craig DeForest 05/20/04 Hacked up Davey code...

Derek Lamb 03/25/05 minor debugging... 
=cut

use Carp;

sub frag_hist {
    my ($opt,$tabs,$ids) = find_opt(@_);
    
    my ($frag_ct, $frame_ct) = $tabs->dims;
    
    my $hist = zeroes( $frag_ct, 11 );
    
    print "Finding start and end times...\n" if($opt->{verbose});
    
    ##############################
    ## Find all the start and end times.  Just find the minimum and maximum
    ## frame for each one.  This is cheesy but oh so sweet.
    
    # frame gets the frame number for all frames with fragments of nonzero size.
    my $frame =  (yvals($frag_ct,$frame_ct)+ones($frag_ct)) * ($tabs->(:,:,(1)) != 0) ;
    
    
    # starts and ends get the max and min frame number for each fragment.
    # (long-named collapse operators collapse in 0th dim only)
    my $ends =   $frame->xchg(0,1)->maximum;
    $ends(1:-1)-=1;
    my $starts = ( $frame + ($ends * ($frame==0)))->xchg(0,1)->minimum;
    $starts(1:-1)-=1;
    $hist->(:,(0)) .= $starts;
    $hist->(:,(3)) .= $ends;
    $hist->(:,(6)) .= $ends - $starts;
    
    $hist->(:,7:8) .= $tabs->(:,:,2:3)->range(yvals(1,$frag_ct)->glue(0,$starts->(*1)));
    $hist->(:,9:10).= $tabs->(:,:,2:3)->range(yvals(1,$frag_ct)->glue(0,$ends->(*1)));
    
    
    
    ##############################
    ## Set up options
    
    $opt->{a} = 1 unless defined ($opt->{a}); 
    $opt->{b} = 4 unless defined ($opt->{b}); 
    $opt->{sep} = 3 unless defined($opt->{sep});
    $opt->{sep} = $opt->{sep}->at(0) if(UNIVERSAL::isa($opt->{sep},'PDL'));
    $opt->{pre} = 1 unless defined($opt->{pre});
    $opt->{post} = 1 unless defined($opt->{post});
    $opt->{ratio} = 0.75 unless defined($opt->{ratio});
    
    my $pre = $opt->{pre};
    my $post = $opt->{post};
    
    print "Separation is ".$opt->{sep}."\n";
    ##############################
    ## Set up variables
    ##
    
    my $i;
    my $frame_offsets = xvals($opt->{post}+$opt->{pre}+1)-$opt->{pre};
    print "frame_offsets is $frame_offsets...\n" if($opt->{verbose});
    
    # The circmask is a precalculated circular mask for convolution to find
    # separation distances between fragments.
    my $circmask = (rvals($opt->{sep}*2+1,$opt->{sep}*2+1)<=$opt->{sep});
    
    ##############################
    ## Loop over fragments and characterize each one.
    
    for $i(1..$frag_ct-1) {
	print "\n$i:\t" if($opt->{verbose});
	
	my $h = $hist->(($i));
	
	
	########### Determine birth method...
	# 
	
	$h->(1:2) .= -1; # Default is ERROR.
	print "-";
	##########
	# SURVIVAL: easiest to check.
	if( $h->(0) == 0 ) {  
	    $h->(1:2) .= 0;  # SURVIVAL
	    print "S" if($opt->{verbose});
	    
	} elsif ( $h->(0) <= $frame_ct-2 ) {  
	    
	    ##########
	    # All other cases are a little harder.  
	    # Do some legwork to assemble an interaction chart.
	    
	    print " ".$h->(0)." " if($opt->{verbose} > 1);
	    my $t = $tabs->(($i),($h->(0)));
	    
	    ##########
	    # Calculate radius to consider.  $r is the calculated radius of the
	    # current fragment if it were circular.  $radius is assembled from 
	    # the a and b coefficients, and the allowed separation.
	    
	    my $r = floor(sqrt($t->((1))/3.14159)+1);
	    my $radius = $opt->{a} + $r*$opt->{b} + $opt->{sep};
	    print "radius=$radius   ";
	    
	    ##########
	    ## Find pixels of interest for this fragment...
	    ## cut out the relevant portion of the ID image with range, 
	    ## mask it to find the equal pixels, then convolve the mask 
	    ## with the circmask to expand it.
	    
	    print "  start frame is ".$h->(0)."; \$t->"."(2:3) is ".$t->(2:3)."   " if($opt->{verbose} > 2);
	    
	    my $mask = (( $ids->[$h->at(0)]->range($t->(2:3)->floor-$radius, $radius*2+1,'t')
			  == $i )->convolveND($circmask) != 0);
	    
	    print ("\nrange:".($ids->[$h->at(0)]->range($t->(2:3)->floor- $radius,$radius*2+1,'t')->abs)."\nmask:".$mask."\n") if($opt->{verbose}>3);
	    
	    ############
	    ## Find interacting fragments for surrounding frames.
	    ## For each frame, pull out the relevant range and multiply by
	    ## the localization mask.  Frames vary from current frame minus $pre
	    ## to current frame plus $pre, clipped to stay in range.
	    my @vicinity = 
		map { $ids->[$_]->range($t->(2:3)-$radius,$radius*2+1,'t') * $mask }
	    (($h->(0) + $frame_offsets)->clip(0,$frame_ct-1)->list);
	    print "::";
	    
	    
	    ## Now sort through to make a list of unique interacting frames.
	    my $interactions = zeroes(1)->
		glue(0, map {$_->uniq->(:)} @vicinity)->short;
	    $interactions->where( $interactions == $i ) .= 0;
	    my @interactions = $interactions->uniq->list;
	    shift @interactions if($interactions[0]==0);
	    print "int - ".join(", ",@interactions)," " if($opt->{verbose}>1);
	    
	    
	    ############
	    # No interactions: it's an appearance.
	    print ".. ";
	    unless(@interactions) {
		print "A" if($opt->{verbose});
		$h->(1:2) .= pdl(1,0);
	    } else {
		print "! ";
		############
		## summary: each row gets (sign, starting, [consistent]),
		## where consistent is consistent with that frag being a source 
		## of the current frag.  Sign is relative to the current 
		## fragment's sign.
		
		my $j;
		
		my @em=();
		my @fr=();
		
		for $j(0..$#interactions) {
		    my $other = $interactions[$j];
		    next if($other >= $tabs->dim(0));
		    print "\nother=$other  " if($opt->{verbose});
		    my $sign = 1 - ($t->((0)) * $tabs->(($other),($starts->($other)),(0))<0)*2;
##$sign is 1 if "this" and "other" are the same sign, -1 if different.
		    
		    print "flux: ".$t->((0))->long."; other: ".$tabs->(($other),($starts->($other)),(0))->long."; sign is $sign\t" if($opt->{verbose} > 1);
		    
		    my $starting = ( ($starts->($other) <= $h->(0) + $post) &&
				     ($starts->($other) >= $h->(0) - $pre)
				     )->at(0);
		    my $ending=( ($ends->($other) <= $h->(0) + $post) &&
				 ($ends->($other) >= $h->(0) - $pre)
				 )->at(0);
##$starting ($ending)isn't used anywhere!  It is a boolean that answers "Does $other start (end) in the frame range we're considering?"
		    
		    
##this is where all the origin decision-making takes place, so need to go over this carefully
		    
		    my $df_other = $tabs->(($other),(pdl($h->((0))-$pre,0)->max),(0)) - $tabs->(($other),(pdl($h->((0))+$post,$frame_ct-1)->min),(0));
		    
# $df_other = $tabs->(($other),($h->(0)-$pre),(0)) - $tabs->(($other),($h->(0)+$post),(0)); 
#delta-flux over frame range (backwards to account for polarity & flux conservation)--but what if h(0)+post goes past the end of the data set? or h(0)-pre goes past the beginning?
		    
		    my $df_this = $tabs->(($i),(pdl($h->((0))+$post,$frame_ct-1)->min),(0));
#$df_this = $tabs->(($i),($h->(0)+$post),(0)); ##no need to subtract as flux was 0 at beginning
		    
		    my $consistent = ($df_other / $df_this > $opt->{ratio});
		    print "df_this:  ".$df_this->long."  df_other: ".$df_other->long."  consistent: $consistent     " if($opt->{verbose} > 1);
		    
		    if($sign < 0 && $consistent) {
			push(@em, $interactions[$j]);
		    } elsif( $sign > 0 && $consistent ) {
			push(@fr, $interactions[$j]);
		    }
		}
##so now @em and @fr contain the ids of those concentrations that consistently interacted with $i to result in an emergence or fragmentation
		
		if(@em && @fr) {
		    $h->(1:2) .= pdl(4,-1);
		    print "*" if($opt->{verbose});
		} elsif(@em) {
		    $h->(1:2) .= pdl(2,@em[0]); ##using the first in the list for the direct object is abitrary
		    print "E" if($opt->{verbose});
		} elsif(@fr) {
		    print "F" if($opt->{verbose});
		    $h->(1:2) .= pdl(3,@fr[0]);
		} else {
		    print "ERROR" if($opt->{verbose});
		}
		
		
	    }
	    
	}
	
	
	
	
	########## Determine death
	print "\n\t" if($opt->{verbose});
	
	if( $h->(3) >= $frame_ct-1 ) { # SURVIVAL
	    $h->(4:5) .= 0;
	    print "S" if($opt->{verbose});
	} else {
	    print "NDD" if($opt->{verbose});
	    
	}
	
	
    }
    
    return $hist;
}
