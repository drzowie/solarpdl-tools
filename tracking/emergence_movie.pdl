=pod

=head2 emergence_movie

=for ref 

Given feature history, tab files, and data frames, generate a movie
showing different types of emergence event.

=for usage 

emergence_movie($hist,$tab,\@data,\@assoc,{options})

C<$hist> is a history table from frag_hist, C<$tab> is a tabulation file
from frag_tabulate, C<\@data> is an array ref of FITS files containing the
original data (or a diskcache object, of course). C<\@assoc> is an array ref of FITS files containing the id masks (i.e., the output of frag_assoc modified by frag_tabulate) (or a diskcache object).

By default the frames are written to the directory "movie"; options can
change the movie directory.

OPTIONS

=over 3

=item dir (default 'movie')

directory in which to write the movie frames.  If it exists, all contents are removed.  If it does not exist, it is created.

=item fname (default 'frame')

Prefix on the image file name

=item size (default [10,10])

Output image size (inches)

=item start (default 4)

number of frames to wait at the start of the movie before showing events

=item pre,post (default 4,20)

Pre and post event illumination frame count

=item range (default [-50,50])

The minimum and maximum pixel intensities to clip to.

=item decay (default 0.94)

Constant to adjust the decay timescale.  Should always be <1.0, smaller means faster decays.

=item evmask (default [1,1,1,1,1,1])

The types of events to highlight.  This needs to be a 6-element array, and each element references the corresponding birth mechanism identified in frag_hist.  The tricky thing is that ERROR (-1) is the last element in evmask, so the order goes:
[Survival, Appearance, Emergence, Fragmentation, Complex, Error]

=item options (default {} )

Any extra options to pass to fits_imag

=item radius (default 20)

Radius (in pixels) of the event circle

=item id_frags (default 0)

Whether to label the concentrations or not.  Setting this to 1 will result in the features being labeled and encircled.  The value of the contour option determines whether the encircling is done with an ellipse (fast, but not accurate) or with the boundary code (slow, but better).

=item contour (default 0)

Whether to draw a boundary around the features (2) or just use a circle (1), or not draw any delimiter at all (0).  This only works if id_frags is 1, otherwise nothing is drawn.

=item anti (default 1)

If greater than 1, divide the image size by this factor before producing the output image.  Also is an adjustment factor in character size of the feature ids.

=back

BUGS

1) What is the correct syntax for the option 'option'?  And why doesn't fits_imag produce a wedge by default?  The documentation says it should.  Think it has something to do with passing in an (x,y,3) piddle--so maybe


HISTORY

Craig DeForest May 2004--original code

Derek Lamb April 2005--bug finding and fixing, added documentation

=cut

use Carp;
use strict;

sub emergence_movie {
    my($hist,$tabs,$data,$ids,$opt) = @_;
    
    $opt = {} unless defined($opt);
    
    my $dir   = $opt->{dir} || "movie/";   # Dir for movies
    my $fname = $opt->{fname} || "frame";  # Frame name template
    my $size  = $opt->{size}  || [10,10];  # Frame size (inches)
    
    my $start = $opt->{start} || 4;        # Don't show events in first n frames
    my $pre   = $opt->{pre}   || 4;        # Pre-illumination frame count
    my $post  = $opt->{post}  || 20;       # Post-illumination frame count
    my $range = $opt->{range} || [-50,50]; # Data range to display
    my $decay = $opt->{decay} || 0.94;
    my $evmask = $opt->{evmask} || [1,1,1,1,1,1];
    my $imag_options = $opt->{options} || {};
    
    my $radius = $opt->{radius} || 20;    # Radius (in pixels) of marks
    
    my $id_frags = $opt->{id_frags} || 0; # whether to label and circle each feature
    my $contour = $opt->{contour} || 0;   # whether to circle each feature
    
    my $ap_color =   pdl(-0.3,0.3,0.6);   # Appearances are bluish
    my $em_color   =  pdl(0.5,0.5,-0.4);  # Emergences are yellow
    
    my $frag_color = pdl(-0.1,0.3,-0.1);  # Fragmentations are green
    my $cmplx_color = pdl(-0.1,-0.1,-0.1); 
    my $err_color = pdl(0.2,-0.1,-0.1); # Errors are faint red
    
    my $anti_alias = $opt->{anti} || 1;
    
    my @colors = (zeroes(3), $ap_color, $em_color, $frag_color, $cmplx_color, $err_color);
    
    
    
    my $rr = rvals(2*$radius+1,2*$radius+1);
    my $cmask = $rr*$rr*$rr*($rr<=$radius);
    $cmask /= $cmask->max;
    
    
    `rm -r $dir`;
    `mkdir $dir`;
    
    my $i;
    my $im;
    use PDL::Transform;
    my $framename;
    for $i(1..$#$data) {
	print "Frame $i...";
	my $w = pgwin(dev=> $framename=sprintf("%s%s%3.3d.ppm/ppm",$dir,$fname,$i),size=>$size);
	# RGB-ify data and scale to [0,1].
	$im = $data->[$i]->float->clip(@$range)->dummy(2,3)->copy;
	$im->sethdr($data->[$i]->hdr_copy);
	$im->hdrcpy(1);
	$im -= $range->[0];
	$im /= ($range->[1]-$range->[0]);
	
	print "...";
	##############################
	# Identify start events and locations
	my $st = which($hist->(:,(0)) >= $i-$post & $hist->(:,(0)) <= $i+$pre);
	print " ".$st->nelem." events...";
	my $event;
	foreach $event($st->list) {
	    
	    my $h = $hist->(($event));
	    next unless( $evmask->[$h->at(1)]);
	    
#     my $grab = ($i<$h->(0)?$h->(7:8):$tabs->(($event),($i),2:3));
	    my $grab = $h->(7:8);
	    
	    my $imr = $im->range($grab-$radius,$radius*2+1,'t');
	    
	    $imr += $cmask * $colors[$h->at(1)]->(*1,*1) * pow($decay,$i+$pre-$h->at(0)) if($evmask->[$h->at(1)]) ;
	    
	    
	}
	
	$w->fits_imag($im->clip(0.01,0.99),0,1,{j=>1,title=>sprintf("MDI Tracked Rgn %s",$im->hdr->{DATE_OBS},$i),dr=>0,charsize=>0.99,%$imag_options});
	$w->hold;
	
	if($id_frags) {
	    my $id;
	    
	    my $t = t_fits($im);
	    
	    my($boundaries)=zeroes(3,1);
	    
	    for $id(which($tabs->(:,($i),((0))))->list) {
		my $xy = $tabs->(($id),($i),2:3)->apply($t);
		my $r = sqrt($tabs->(($id),($i),(1))/3.14159) * $im->hdr->{CDELT1};
		
		if($contour==2) {
		    $boundaries(2,-1) .= 0; # lift up pen
		    my $l = boundary($id,$tabs->(($id),($i)),$ids->[$i]);
		    $boundaries = $boundaries->glue(1,$l);
		} elsif($contour==1) {
		    $w->ellipse($xy->at(0),$xy->at(1),$r,$r,{fill=>2,color=>3});
		}
		
		$w->text($id,$xy->at(0)+$r*1.05,$xy->at(1),{charsize=>0.67*$anti_alias,color=>3});
		print ".";
	    }
	    
	    if($contour==2) {
		$w->lines( $boundaries->apply($t),{color=>3});
	    }
	    
	}
	$w->close;
	if($anti_alias > 1) {
	    $im = rim($framename);
	    $im = $im->match([(pdl($im->dims)/$anti_alias)->short->list],{method=>'h'});
	    wim($im,$framename);
	}
    } # frame loop
}
