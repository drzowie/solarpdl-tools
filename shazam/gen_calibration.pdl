=head2 gen_calibration - make a calibration object, given dark and flat field data

=for usage

$cal = gen_calibration($darks, $flats, [$order], [$intended_exp])

=for ref

You hand over exposure sequence objects (from
collect_exposure_sequence) and you get back a prefrobnicated
calibration object.  The darks and flats should have the same set of
exposure times (we check), and should also have been exposed using a
true flat fed into the cameras. This step handles the nonlinear calibration of the 
cameras, but not flat field effects due to the polarizer rotation; that should be 
handled separately by dividing out polarized flat fields.

You get back a calibration curve for each pixel that is a polynomial 
fit of order $order; the output is an O x Nx x Ny PDL containing the polynomial
coefficients.  A separate PDL contains a flag for bad pixels (1 where they are bad).

If you specify the intended exposure time then the $darks are discarded and 
the return value gets just a single dark frame for the intended exposure time.

The coefficients are normalized to 

The output is an array ref: [ $darks, $coeffs, $bad ];

=for author

Craig DeForest

=for history 

0.1 9-May-2009

=cut

sub gen_calibration {
    my $darks = shift;
    my $flats = shift;
    my $n = shift || 10;
    my $normalization = shift || 1;

    # Check exposure times
    if( $darks->[0]->nelem != $flats->[0]->nelem) {
	die("Dark counts don't match flat counts");
    }

    if( any($darks->[0] != $flats->[0]) ) {
	print "WARNING: dark and flat exposure times differ\n";
    }

    $fl = $flats->[1];
    $dk = $darks->[1];


    # Dark-correct the flat exposure files
    $fl -= $dk unless($flats->[2]);
    $flats->[2] = 1;

    # Get the range of the flat exposure files
    $max = $fl->((-1));
    $min = $fl->((0));


    # Allocate the tiepoints array...
    # (tiepoints are exposure values, in ms of flat field, for particular 
    # DN values that are sampled on a regular grid between $min and $max.

    # First set the tiepoints based on a linear scale...
    $ties = xvals(float, $n, $flats->[1]->dim(1), $flats->[1]->dim(2))/($n-1) * ($flats->[0]->((1))-$flats->[0]->((0))) + $flats->[0]->((0));


    # Now loop several times, adjusting each tiepoint to the optimum assuming its neighbors stay fixed.
    # (we hope that this converges...)

    ## FIXME - put loop in!

    $out = {dark  => $dk,
    	    min   => $min,
	    range => $max - $min,
	    ties  => $ties
	    };
    
    return $out;
    
        


}

