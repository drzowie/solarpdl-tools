/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.21 from the
 * contents of eval_101_638e.xs. Do not edit this file, edit eval_101_638e.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "eval_101_638e.xs"

/*
 * THIS FILE WAS GENERATED BY PDL::PP! Do not modify!
 */

#define PDL_COMMENT(comment)
PDL_COMMENT("This preprocessor symbol is used to add commentary in the PDL  ")
PDL_COMMENT("autogenerated code. Normally, one would use typical C-style    ")
PDL_COMMENT("multiline comments (i.e. /* comment */). However, because such ")
PDL_COMMENT("comments do not nest, it's not possible for PDL::PP users to   ")
PDL_COMMENT("comment-out sections of code using multiline comments, as is   ")
PDL_COMMENT("often the practice when debugging, for example. So, when you   ")
PDL_COMMENT("see something like this:                                       ")
PDL_COMMENT("                                                               ")
                PDL_COMMENT("Memory access")
PDL_COMMENT("                                                               ")
PDL_COMMENT("just think of it as a C multiline comment like:                ")
PDL_COMMENT("                                                               ")
PDL_COMMENT("   /* Memory access */                                         ")

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "pdl.h"
#include "pdlcore.h"
static Core* PDL; PDL_COMMENT("Structure hold core C functions")
static int __pdl_debugging = 0;
static int __pdl_boundscheck = 0;
static SV* CoreSV;       PDL_COMMENT("Gets pointer to perl var holding core structure")

#if ! 1
# define PP_INDTERM(max, at) at
#else
# define PP_INDTERM(max, at) (__pdl_boundscheck? PDL->safe_indterm(max,at, __FILE__, __LINE__) : at)
#endif


typedef struct pdl_my_cspline_irregular_struct {
		PDL_TRANS_START(5);
		pdl_thread  __pdlthread;PDL_Long  __inc_x_k;PDL_Long  __inc_dat_k;PDL_Long  __k_size;
		char  bound;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_my_cspline_irregular_struct;

void pdl_my_cspline_irregular_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_my_cspline_irregular_struct *__privtrans = (pdl_my_cspline_irregular_struct *) __tr;
	
	{
	    int __creating[5];
__privtrans->__k_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[4]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_B: {
	PDL_Byte * x_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Byte * x_physdatap = ((PDL_Byte *)((__privtrans->pdls[0])->data));

	PDL_Byte * dat_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Byte * dat_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));

	PDL_Byte * xloc_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Byte * xloc_physdatap = ((PDL_Byte *)((__privtrans->pdls[2])->data));

	PDL_Byte * c_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Byte * c_physdatap = ((PDL_Byte *)((__privtrans->pdls[3])->data));

	PDL_Byte * out_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Byte * out_physdatap = ((PDL_Byte *)((__privtrans->pdls[4])->data));

{register PDL_Long __inc_dat_k = __privtrans->__inc_dat_k;
register PDL_Long __inc_x_k = __privtrans->__inc_x_k;

PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Short * x_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Short * x_physdatap = ((PDL_Short *)((__privtrans->pdls[0])->data));

	PDL_Short * dat_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Short * dat_physdatap = ((PDL_Short *)((__privtrans->pdls[1])->data));

	PDL_Short * xloc_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Short * xloc_physdatap = ((PDL_Short *)((__privtrans->pdls[2])->data));

	PDL_Short * c_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Short * c_physdatap = ((PDL_Short *)((__privtrans->pdls[3])->data));

	PDL_Short * out_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Short * out_physdatap = ((PDL_Short *)((__privtrans->pdls[4])->data));

{register PDL_Long __inc_dat_k = __privtrans->__inc_dat_k;
register PDL_Long __inc_x_k = __privtrans->__inc_x_k;

PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Ushort * x_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Ushort * x_physdatap = ((PDL_Ushort *)((__privtrans->pdls[0])->data));

	PDL_Ushort * dat_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Ushort * dat_physdatap = ((PDL_Ushort *)((__privtrans->pdls[1])->data));

	PDL_Ushort * xloc_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Ushort * xloc_physdatap = ((PDL_Ushort *)((__privtrans->pdls[2])->data));

	PDL_Ushort * c_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Ushort * c_physdatap = ((PDL_Ushort *)((__privtrans->pdls[3])->data));

	PDL_Ushort * out_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Ushort * out_physdatap = ((PDL_Ushort *)((__privtrans->pdls[4])->data));

{register PDL_Long __inc_dat_k = __privtrans->__inc_dat_k;
register PDL_Long __inc_x_k = __privtrans->__inc_x_k;

PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Long * x_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * x_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * dat_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * dat_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * xloc_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * xloc_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * c_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * c_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * out_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * out_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{register PDL_Long __inc_dat_k = __privtrans->__inc_dat_k;
register PDL_Long __inc_x_k = __privtrans->__inc_x_k;

PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_LongLong * x_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_LongLong * x_physdatap = ((PDL_LongLong *)((__privtrans->pdls[0])->data));

	PDL_LongLong * dat_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_LongLong * dat_physdatap = ((PDL_LongLong *)((__privtrans->pdls[1])->data));

	PDL_LongLong * xloc_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_LongLong * xloc_physdatap = ((PDL_LongLong *)((__privtrans->pdls[2])->data));

	PDL_LongLong * c_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_LongLong * c_physdatap = ((PDL_LongLong *)((__privtrans->pdls[3])->data));

	PDL_LongLong * out_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_LongLong * out_physdatap = ((PDL_LongLong *)((__privtrans->pdls[4])->data));

{register PDL_Long __inc_dat_k = __privtrans->__inc_dat_k;
register PDL_Long __inc_x_k = __privtrans->__inc_x_k;

PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Float * x_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Float * x_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));

	PDL_Float * dat_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Float * dat_physdatap = ((PDL_Float *)((__privtrans->pdls[1])->data));

	PDL_Float * xloc_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Float * xloc_physdatap = ((PDL_Float *)((__privtrans->pdls[2])->data));

	PDL_Float * c_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Float * c_physdatap = ((PDL_Float *)((__privtrans->pdls[3])->data));

	PDL_Float * out_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Float * out_physdatap = ((PDL_Float *)((__privtrans->pdls[4])->data));

{register PDL_Long __inc_dat_k = __privtrans->__inc_dat_k;
register PDL_Long __inc_x_k = __privtrans->__inc_x_k;

PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * dat_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * dat_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * xloc_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * xloc_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * c_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * c_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * out_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * out_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{register PDL_Long __inc_dat_k = __privtrans->__inc_dat_k;
register PDL_Long __inc_x_k = __privtrans->__inc_x_k;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"x","dat","xloc","c","out"};
		static int __realdims[] = {1,1,0,0,0};
		static char __funcname[] = "eval_101_638e::my_cspline_irregular";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 5
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,5,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__k_size <= 1) __privtrans->__k_size = 1;
   }
   if(__privtrans->__k_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__k_size == 1)) {
      __privtrans->__k_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__k_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in my_cspline_irregular:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__k_size <= 1) __privtrans->__k_size = 1;
   }
   if(__privtrans->__k_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__k_size == 1)) {
      __privtrans->__k_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__k_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in my_cspline_irregular:" "Wrong dims\n");
      }
   }
if(!__creating[4]) {
} else {
 int dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,4,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[4] && 
     __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[4]->hdrsv != hdrp ){
	 if( __privtrans->pdls[4]->hdrsv && __privtrans->pdls[4]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[4]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[4]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[4]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_x_k = 0; else
		 __privtrans->__inc_x_k = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_dat_k = 0; else
		 __privtrans->__inc_dat_k = PDL_REPRINC(__privtrans->pdls[1],0); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_my_cspline_irregular_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_my_cspline_irregular_struct *__privtrans = (pdl_my_cspline_irregular_struct *) __tr;
	
	{
	    pdl_my_cspline_irregular_struct *__copy = malloc(sizeof(pdl_my_cspline_irregular_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->bound) = (__privtrans->bound);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_x_k=__copy->__inc_x_k;__privtrans->__inc_dat_k=__copy->__inc_dat_k;__copy->__k_size=__privtrans->__k_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_my_cspline_irregular_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_my_cspline_irregular_struct *__privtrans = (pdl_my_cspline_irregular_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {1;
	} break; case PDL_B: {
	PDL_Byte * x_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Byte * x_physdatap = ((PDL_Byte *)((__privtrans->pdls[0])->data));

	PDL_Byte * dat_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Byte * dat_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));

	PDL_Byte * xloc_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Byte * xloc_physdatap = ((PDL_Byte *)((__privtrans->pdls[2])->data));

	PDL_Byte * c_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Byte * c_physdatap = ((PDL_Byte *)((__privtrans->pdls[3])->data));

	PDL_Byte * out_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Byte * out_physdatap = ((PDL_Byte *)((__privtrans->pdls[4])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];x_datap += __offsp[0];
dat_datap += __offsp[1];
xloc_datap += __offsp[2];
c_datap += __offsp[3];
out_datap += __offsp[4];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_dat_k = __privtrans->__inc_dat_k;
register PDL_Long __inc_x_k = __privtrans->__inc_x_k;

	long i;
	long dex;
	long dexlo;
        double xlo;
        double xhi;
        double x;
	long dexhi;
        double p[4];
       double xp[4];
       long n;

       n = __privtrans->__k_size;

              {
	   	   dexlo = 0;
	   dexhi = n-1;
	   xlo = (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, 0))] PDL_COMMENT("ACCESS()") ;
	   xhi = (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, n-1))] PDL_COMMENT("ACCESS()") ;
	   dex = dexhi;

	   while((dexlo < dexhi - 1)) {
	       dex = (dexlo + dexhi)/2;
	       if(dex >= 0) {
		 x = (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, dex))] PDL_COMMENT("ACCESS()") ;
		 if(x > (xloc_datap)[0] PDL_COMMENT("ACCESS()") ) {
		   dexhi = dex;
		   xhi = x;
		 } else {
		   dexlo = dex;
		   xlo = x;
		 }
		 if(xlo >= xhi)
		   barf("data source is non monotonic!\n");
	       }
	   }
       }

                     
              printf("val=%g, dex=%d\\n",(float)(xloc_datap)[0] PDL_COMMENT("ACCESS()") , $dex);
       dex = dexlo - 1;
       for(i=0; i<4; i++,dex++) {
	   if(dex<0 || dex > n-1) {
	       p[i]   = (dex<0) ? (dat_datap)[0+(__inc_dat_k*PP_INDTERM(__privtrans->__k_size, 0))] PDL_COMMENT("ACCESS()")  : (dat_datap)[0+(__inc_dat_k*PP_INDTERM(__privtrans->__k_size, n-1))] PDL_COMMENT("ACCESS()") ; 
	       xp[i]  = (dex<0) ? ((x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, 0))] PDL_COMMENT("ACCESS()")  + ((x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, 1))] PDL_COMMENT("ACCESS()")  - (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, 0))] PDL_COMMENT("ACCESS()") ) * dex)   : (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, n-1))] PDL_COMMENT("ACCESS()")  + ((x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, n-1))] PDL_COMMENT("ACCESS()")  - (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, n-2))] PDL_COMMENT("ACCESS()") )*(dex - (n-1));
	       break;
	   } else {
	       p[i] = (dat_datap)[0+(__inc_dat_k*PP_INDTERM(__privtrans->__k_size, dex))] PDL_COMMENT("ACCESS()") ;
	       xp[i] = (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, dex))] PDL_COMMENT("ACCESS()") ;
	   }
       }

              {
	   if(xp[3]==xp[2]) 
	       xp[3]++;
	   if(xp[0] == xp[1]) 
	       xp[0]--;

	   double t = ((xloc_datap)[0] PDL_COMMENT("ACCESS()")  - xlo) / (xp[2]-xlo);
	   double t1 = 1 - t;
	   double h00 = (1 + 2*t) * t1 * t1;
	   double h10 = t * t1 * t1;
	   double h01 = t * t * (3 - 2*t);
	   double h11 = - t * t * t1;

	   double m0 = (1 - (c_datap)[0] PDL_COMMENT("ACCESS()") ) * 0.5 * ( (p[2] - p[1]) / (xp[2]-xp[1]) + (p[1]-p[0]) / (xp[1]-xp[0]));
	   double m1 = (1 - (c_datap)[0] PDL_COMMENT("ACCESS()") ) * 0.5 * ( (p[3] - p[2]) / (xp[3]-xp[2]) + (p[2]-p[1]) / (xp[1]-xp[0]));

	 (out_datap)[0] PDL_COMMENT("ACCESS()")  = h00 * p[1] + h10 * m0 * (xp[2]-xlo) + h01 * p[2] + h11 * m1 * (xp[2]-xlo);
       }



}	PDL_COMMENT("THREADLOOPEND")
	 x_datap += __tinc0_0;
dat_datap += __tinc0_1;
xloc_datap += __tinc0_2;
c_datap += __tinc0_3;
out_datap += __tinc0_4;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
dat_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
xloc_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
c_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
out_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;dat_datap -= __tinc1_1 *
     				  __tdims1;xloc_datap -= __tinc1_2 *
     				  __tdims1;c_datap -= __tinc1_3 *
     				  __tdims1;out_datap -= __tinc1_4 *
     				  __tdims1;
 x_datap -= __offsp[0];
dat_datap -= __offsp[1];
xloc_datap -= __offsp[2];
c_datap -= __offsp[3];
out_datap -= __offsp[4];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_S: {
	PDL_Short * x_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Short * x_physdatap = ((PDL_Short *)((__privtrans->pdls[0])->data));

	PDL_Short * dat_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Short * dat_physdatap = ((PDL_Short *)((__privtrans->pdls[1])->data));

	PDL_Short * xloc_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Short * xloc_physdatap = ((PDL_Short *)((__privtrans->pdls[2])->data));

	PDL_Short * c_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Short * c_physdatap = ((PDL_Short *)((__privtrans->pdls[3])->data));

	PDL_Short * out_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Short * out_physdatap = ((PDL_Short *)((__privtrans->pdls[4])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];x_datap += __offsp[0];
dat_datap += __offsp[1];
xloc_datap += __offsp[2];
c_datap += __offsp[3];
out_datap += __offsp[4];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_dat_k = __privtrans->__inc_dat_k;
register PDL_Long __inc_x_k = __privtrans->__inc_x_k;

	long i;
	long dex;
	long dexlo;
        double xlo;
        double xhi;
        double x;
	long dexhi;
        double p[4];
       double xp[4];
       long n;

       n = __privtrans->__k_size;

              {
	   	   dexlo = 0;
	   dexhi = n-1;
	   xlo = (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, 0))] PDL_COMMENT("ACCESS()") ;
	   xhi = (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, n-1))] PDL_COMMENT("ACCESS()") ;
	   dex = dexhi;

	   while((dexlo < dexhi - 1)) {
	       dex = (dexlo + dexhi)/2;
	       if(dex >= 0) {
		 x = (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, dex))] PDL_COMMENT("ACCESS()") ;
		 if(x > (xloc_datap)[0] PDL_COMMENT("ACCESS()") ) {
		   dexhi = dex;
		   xhi = x;
		 } else {
		   dexlo = dex;
		   xlo = x;
		 }
		 if(xlo >= xhi)
		   barf("data source is non monotonic!\n");
	       }
	   }
       }

                     
              printf("val=%g, dex=%d\\n",(float)(xloc_datap)[0] PDL_COMMENT("ACCESS()") , $dex);
       dex = dexlo - 1;
       for(i=0; i<4; i++,dex++) {
	   if(dex<0 || dex > n-1) {
	       p[i]   = (dex<0) ? (dat_datap)[0+(__inc_dat_k*PP_INDTERM(__privtrans->__k_size, 0))] PDL_COMMENT("ACCESS()")  : (dat_datap)[0+(__inc_dat_k*PP_INDTERM(__privtrans->__k_size, n-1))] PDL_COMMENT("ACCESS()") ; 
	       xp[i]  = (dex<0) ? ((x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, 0))] PDL_COMMENT("ACCESS()")  + ((x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, 1))] PDL_COMMENT("ACCESS()")  - (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, 0))] PDL_COMMENT("ACCESS()") ) * dex)   : (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, n-1))] PDL_COMMENT("ACCESS()")  + ((x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, n-1))] PDL_COMMENT("ACCESS()")  - (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, n-2))] PDL_COMMENT("ACCESS()") )*(dex - (n-1));
	       break;
	   } else {
	       p[i] = (dat_datap)[0+(__inc_dat_k*PP_INDTERM(__privtrans->__k_size, dex))] PDL_COMMENT("ACCESS()") ;
	       xp[i] = (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, dex))] PDL_COMMENT("ACCESS()") ;
	   }
       }

              {
	   if(xp[3]==xp[2]) 
	       xp[3]++;
	   if(xp[0] == xp[1]) 
	       xp[0]--;

	   double t = ((xloc_datap)[0] PDL_COMMENT("ACCESS()")  - xlo) / (xp[2]-xlo);
	   double t1 = 1 - t;
	   double h00 = (1 + 2*t) * t1 * t1;
	   double h10 = t * t1 * t1;
	   double h01 = t * t * (3 - 2*t);
	   double h11 = - t * t * t1;

	   double m0 = (1 - (c_datap)[0] PDL_COMMENT("ACCESS()") ) * 0.5 * ( (p[2] - p[1]) / (xp[2]-xp[1]) + (p[1]-p[0]) / (xp[1]-xp[0]));
	   double m1 = (1 - (c_datap)[0] PDL_COMMENT("ACCESS()") ) * 0.5 * ( (p[3] - p[2]) / (xp[3]-xp[2]) + (p[2]-p[1]) / (xp[1]-xp[0]));

	 (out_datap)[0] PDL_COMMENT("ACCESS()")  = h00 * p[1] + h10 * m0 * (xp[2]-xlo) + h01 * p[2] + h11 * m1 * (xp[2]-xlo);
       }



}	PDL_COMMENT("THREADLOOPEND")
	 x_datap += __tinc0_0;
dat_datap += __tinc0_1;
xloc_datap += __tinc0_2;
c_datap += __tinc0_3;
out_datap += __tinc0_4;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
dat_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
xloc_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
c_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
out_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;dat_datap -= __tinc1_1 *
     				  __tdims1;xloc_datap -= __tinc1_2 *
     				  __tdims1;c_datap -= __tinc1_3 *
     				  __tdims1;out_datap -= __tinc1_4 *
     				  __tdims1;
 x_datap -= __offsp[0];
dat_datap -= __offsp[1];
xloc_datap -= __offsp[2];
c_datap -= __offsp[3];
out_datap -= __offsp[4];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_US: {
	PDL_Ushort * x_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Ushort * x_physdatap = ((PDL_Ushort *)((__privtrans->pdls[0])->data));

	PDL_Ushort * dat_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Ushort * dat_physdatap = ((PDL_Ushort *)((__privtrans->pdls[1])->data));

	PDL_Ushort * xloc_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Ushort * xloc_physdatap = ((PDL_Ushort *)((__privtrans->pdls[2])->data));

	PDL_Ushort * c_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Ushort * c_physdatap = ((PDL_Ushort *)((__privtrans->pdls[3])->data));

	PDL_Ushort * out_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Ushort * out_physdatap = ((PDL_Ushort *)((__privtrans->pdls[4])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];x_datap += __offsp[0];
dat_datap += __offsp[1];
xloc_datap += __offsp[2];
c_datap += __offsp[3];
out_datap += __offsp[4];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_dat_k = __privtrans->__inc_dat_k;
register PDL_Long __inc_x_k = __privtrans->__inc_x_k;

	long i;
	long dex;
	long dexlo;
        double xlo;
        double xhi;
        double x;
	long dexhi;
        double p[4];
       double xp[4];
       long n;

       n = __privtrans->__k_size;

              {
	   	   dexlo = 0;
	   dexhi = n-1;
	   xlo = (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, 0))] PDL_COMMENT("ACCESS()") ;
	   xhi = (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, n-1))] PDL_COMMENT("ACCESS()") ;
	   dex = dexhi;

	   while((dexlo < dexhi - 1)) {
	       dex = (dexlo + dexhi)/2;
	       if(dex >= 0) {
		 x = (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, dex))] PDL_COMMENT("ACCESS()") ;
		 if(x > (xloc_datap)[0] PDL_COMMENT("ACCESS()") ) {
		   dexhi = dex;
		   xhi = x;
		 } else {
		   dexlo = dex;
		   xlo = x;
		 }
		 if(xlo >= xhi)
		   barf("data source is non monotonic!\n");
	       }
	   }
       }

                     
              printf("val=%g, dex=%d\\n",(float)(xloc_datap)[0] PDL_COMMENT("ACCESS()") , $dex);
       dex = dexlo - 1;
       for(i=0; i<4; i++,dex++) {
	   if(dex<0 || dex > n-1) {
	       p[i]   = (dex<0) ? (dat_datap)[0+(__inc_dat_k*PP_INDTERM(__privtrans->__k_size, 0))] PDL_COMMENT("ACCESS()")  : (dat_datap)[0+(__inc_dat_k*PP_INDTERM(__privtrans->__k_size, n-1))] PDL_COMMENT("ACCESS()") ; 
	       xp[i]  = (dex<0) ? ((x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, 0))] PDL_COMMENT("ACCESS()")  + ((x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, 1))] PDL_COMMENT("ACCESS()")  - (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, 0))] PDL_COMMENT("ACCESS()") ) * dex)   : (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, n-1))] PDL_COMMENT("ACCESS()")  + ((x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, n-1))] PDL_COMMENT("ACCESS()")  - (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, n-2))] PDL_COMMENT("ACCESS()") )*(dex - (n-1));
	       break;
	   } else {
	       p[i] = (dat_datap)[0+(__inc_dat_k*PP_INDTERM(__privtrans->__k_size, dex))] PDL_COMMENT("ACCESS()") ;
	       xp[i] = (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, dex))] PDL_COMMENT("ACCESS()") ;
	   }
       }

              {
	   if(xp[3]==xp[2]) 
	       xp[3]++;
	   if(xp[0] == xp[1]) 
	       xp[0]--;

	   double t = ((xloc_datap)[0] PDL_COMMENT("ACCESS()")  - xlo) / (xp[2]-xlo);
	   double t1 = 1 - t;
	   double h00 = (1 + 2*t) * t1 * t1;
	   double h10 = t * t1 * t1;
	   double h01 = t * t * (3 - 2*t);
	   double h11 = - t * t * t1;

	   double m0 = (1 - (c_datap)[0] PDL_COMMENT("ACCESS()") ) * 0.5 * ( (p[2] - p[1]) / (xp[2]-xp[1]) + (p[1]-p[0]) / (xp[1]-xp[0]));
	   double m1 = (1 - (c_datap)[0] PDL_COMMENT("ACCESS()") ) * 0.5 * ( (p[3] - p[2]) / (xp[3]-xp[2]) + (p[2]-p[1]) / (xp[1]-xp[0]));

	 (out_datap)[0] PDL_COMMENT("ACCESS()")  = h00 * p[1] + h10 * m0 * (xp[2]-xlo) + h01 * p[2] + h11 * m1 * (xp[2]-xlo);
       }



}	PDL_COMMENT("THREADLOOPEND")
	 x_datap += __tinc0_0;
dat_datap += __tinc0_1;
xloc_datap += __tinc0_2;
c_datap += __tinc0_3;
out_datap += __tinc0_4;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
dat_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
xloc_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
c_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
out_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;dat_datap -= __tinc1_1 *
     				  __tdims1;xloc_datap -= __tinc1_2 *
     				  __tdims1;c_datap -= __tinc1_3 *
     				  __tdims1;out_datap -= __tinc1_4 *
     				  __tdims1;
 x_datap -= __offsp[0];
dat_datap -= __offsp[1];
xloc_datap -= __offsp[2];
c_datap -= __offsp[3];
out_datap -= __offsp[4];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_L: {
	PDL_Long * x_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * x_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * dat_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * dat_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * xloc_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * xloc_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * c_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * c_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * out_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * out_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];x_datap += __offsp[0];
dat_datap += __offsp[1];
xloc_datap += __offsp[2];
c_datap += __offsp[3];
out_datap += __offsp[4];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_dat_k = __privtrans->__inc_dat_k;
register PDL_Long __inc_x_k = __privtrans->__inc_x_k;

	long i;
	long dex;
	long dexlo;
        double xlo;
        double xhi;
        double x;
	long dexhi;
        double p[4];
       double xp[4];
       long n;

       n = __privtrans->__k_size;

              {
	   	   dexlo = 0;
	   dexhi = n-1;
	   xlo = (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, 0))] PDL_COMMENT("ACCESS()") ;
	   xhi = (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, n-1))] PDL_COMMENT("ACCESS()") ;
	   dex = dexhi;

	   while((dexlo < dexhi - 1)) {
	       dex = (dexlo + dexhi)/2;
	       if(dex >= 0) {
		 x = (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, dex))] PDL_COMMENT("ACCESS()") ;
		 if(x > (xloc_datap)[0] PDL_COMMENT("ACCESS()") ) {
		   dexhi = dex;
		   xhi = x;
		 } else {
		   dexlo = dex;
		   xlo = x;
		 }
		 if(xlo >= xhi)
		   barf("data source is non monotonic!\n");
	       }
	   }
       }

                     
              printf("val=%g, dex=%d\\n",(float)(xloc_datap)[0] PDL_COMMENT("ACCESS()") , $dex);
       dex = dexlo - 1;
       for(i=0; i<4; i++,dex++) {
	   if(dex<0 || dex > n-1) {
	       p[i]   = (dex<0) ? (dat_datap)[0+(__inc_dat_k*PP_INDTERM(__privtrans->__k_size, 0))] PDL_COMMENT("ACCESS()")  : (dat_datap)[0+(__inc_dat_k*PP_INDTERM(__privtrans->__k_size, n-1))] PDL_COMMENT("ACCESS()") ; 
	       xp[i]  = (dex<0) ? ((x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, 0))] PDL_COMMENT("ACCESS()")  + ((x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, 1))] PDL_COMMENT("ACCESS()")  - (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, 0))] PDL_COMMENT("ACCESS()") ) * dex)   : (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, n-1))] PDL_COMMENT("ACCESS()")  + ((x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, n-1))] PDL_COMMENT("ACCESS()")  - (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, n-2))] PDL_COMMENT("ACCESS()") )*(dex - (n-1));
	       break;
	   } else {
	       p[i] = (dat_datap)[0+(__inc_dat_k*PP_INDTERM(__privtrans->__k_size, dex))] PDL_COMMENT("ACCESS()") ;
	       xp[i] = (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, dex))] PDL_COMMENT("ACCESS()") ;
	   }
       }

              {
	   if(xp[3]==xp[2]) 
	       xp[3]++;
	   if(xp[0] == xp[1]) 
	       xp[0]--;

	   double t = ((xloc_datap)[0] PDL_COMMENT("ACCESS()")  - xlo) / (xp[2]-xlo);
	   double t1 = 1 - t;
	   double h00 = (1 + 2*t) * t1 * t1;
	   double h10 = t * t1 * t1;
	   double h01 = t * t * (3 - 2*t);
	   double h11 = - t * t * t1;

	   double m0 = (1 - (c_datap)[0] PDL_COMMENT("ACCESS()") ) * 0.5 * ( (p[2] - p[1]) / (xp[2]-xp[1]) + (p[1]-p[0]) / (xp[1]-xp[0]));
	   double m1 = (1 - (c_datap)[0] PDL_COMMENT("ACCESS()") ) * 0.5 * ( (p[3] - p[2]) / (xp[3]-xp[2]) + (p[2]-p[1]) / (xp[1]-xp[0]));

	 (out_datap)[0] PDL_COMMENT("ACCESS()")  = h00 * p[1] + h10 * m0 * (xp[2]-xlo) + h01 * p[2] + h11 * m1 * (xp[2]-xlo);
       }



}	PDL_COMMENT("THREADLOOPEND")
	 x_datap += __tinc0_0;
dat_datap += __tinc0_1;
xloc_datap += __tinc0_2;
c_datap += __tinc0_3;
out_datap += __tinc0_4;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
dat_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
xloc_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
c_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
out_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;dat_datap -= __tinc1_1 *
     				  __tdims1;xloc_datap -= __tinc1_2 *
     				  __tdims1;c_datap -= __tinc1_3 *
     				  __tdims1;out_datap -= __tinc1_4 *
     				  __tdims1;
 x_datap -= __offsp[0];
dat_datap -= __offsp[1];
xloc_datap -= __offsp[2];
c_datap -= __offsp[3];
out_datap -= __offsp[4];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_LL: {
	PDL_LongLong * x_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_LongLong * x_physdatap = ((PDL_LongLong *)((__privtrans->pdls[0])->data));

	PDL_LongLong * dat_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_LongLong * dat_physdatap = ((PDL_LongLong *)((__privtrans->pdls[1])->data));

	PDL_LongLong * xloc_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_LongLong * xloc_physdatap = ((PDL_LongLong *)((__privtrans->pdls[2])->data));

	PDL_LongLong * c_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_LongLong * c_physdatap = ((PDL_LongLong *)((__privtrans->pdls[3])->data));

	PDL_LongLong * out_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_LongLong * out_physdatap = ((PDL_LongLong *)((__privtrans->pdls[4])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];x_datap += __offsp[0];
dat_datap += __offsp[1];
xloc_datap += __offsp[2];
c_datap += __offsp[3];
out_datap += __offsp[4];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_dat_k = __privtrans->__inc_dat_k;
register PDL_Long __inc_x_k = __privtrans->__inc_x_k;

	long i;
	long dex;
	long dexlo;
        double xlo;
        double xhi;
        double x;
	long dexhi;
        double p[4];
       double xp[4];
       long n;

       n = __privtrans->__k_size;

              {
	   	   dexlo = 0;
	   dexhi = n-1;
	   xlo = (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, 0))] PDL_COMMENT("ACCESS()") ;
	   xhi = (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, n-1))] PDL_COMMENT("ACCESS()") ;
	   dex = dexhi;

	   while((dexlo < dexhi - 1)) {
	       dex = (dexlo + dexhi)/2;
	       if(dex >= 0) {
		 x = (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, dex))] PDL_COMMENT("ACCESS()") ;
		 if(x > (xloc_datap)[0] PDL_COMMENT("ACCESS()") ) {
		   dexhi = dex;
		   xhi = x;
		 } else {
		   dexlo = dex;
		   xlo = x;
		 }
		 if(xlo >= xhi)
		   barf("data source is non monotonic!\n");
	       }
	   }
       }

                     
              printf("val=%g, dex=%d\\n",(float)(xloc_datap)[0] PDL_COMMENT("ACCESS()") , $dex);
       dex = dexlo - 1;
       for(i=0; i<4; i++,dex++) {
	   if(dex<0 || dex > n-1) {
	       p[i]   = (dex<0) ? (dat_datap)[0+(__inc_dat_k*PP_INDTERM(__privtrans->__k_size, 0))] PDL_COMMENT("ACCESS()")  : (dat_datap)[0+(__inc_dat_k*PP_INDTERM(__privtrans->__k_size, n-1))] PDL_COMMENT("ACCESS()") ; 
	       xp[i]  = (dex<0) ? ((x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, 0))] PDL_COMMENT("ACCESS()")  + ((x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, 1))] PDL_COMMENT("ACCESS()")  - (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, 0))] PDL_COMMENT("ACCESS()") ) * dex)   : (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, n-1))] PDL_COMMENT("ACCESS()")  + ((x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, n-1))] PDL_COMMENT("ACCESS()")  - (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, n-2))] PDL_COMMENT("ACCESS()") )*(dex - (n-1));
	       break;
	   } else {
	       p[i] = (dat_datap)[0+(__inc_dat_k*PP_INDTERM(__privtrans->__k_size, dex))] PDL_COMMENT("ACCESS()") ;
	       xp[i] = (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, dex))] PDL_COMMENT("ACCESS()") ;
	   }
       }

              {
	   if(xp[3]==xp[2]) 
	       xp[3]++;
	   if(xp[0] == xp[1]) 
	       xp[0]--;

	   double t = ((xloc_datap)[0] PDL_COMMENT("ACCESS()")  - xlo) / (xp[2]-xlo);
	   double t1 = 1 - t;
	   double h00 = (1 + 2*t) * t1 * t1;
	   double h10 = t * t1 * t1;
	   double h01 = t * t * (3 - 2*t);
	   double h11 = - t * t * t1;

	   double m0 = (1 - (c_datap)[0] PDL_COMMENT("ACCESS()") ) * 0.5 * ( (p[2] - p[1]) / (xp[2]-xp[1]) + (p[1]-p[0]) / (xp[1]-xp[0]));
	   double m1 = (1 - (c_datap)[0] PDL_COMMENT("ACCESS()") ) * 0.5 * ( (p[3] - p[2]) / (xp[3]-xp[2]) + (p[2]-p[1]) / (xp[1]-xp[0]));

	 (out_datap)[0] PDL_COMMENT("ACCESS()")  = h00 * p[1] + h10 * m0 * (xp[2]-xlo) + h01 * p[2] + h11 * m1 * (xp[2]-xlo);
       }



}	PDL_COMMENT("THREADLOOPEND")
	 x_datap += __tinc0_0;
dat_datap += __tinc0_1;
xloc_datap += __tinc0_2;
c_datap += __tinc0_3;
out_datap += __tinc0_4;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
dat_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
xloc_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
c_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
out_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;dat_datap -= __tinc1_1 *
     				  __tdims1;xloc_datap -= __tinc1_2 *
     				  __tdims1;c_datap -= __tinc1_3 *
     				  __tdims1;out_datap -= __tinc1_4 *
     				  __tdims1;
 x_datap -= __offsp[0];
dat_datap -= __offsp[1];
xloc_datap -= __offsp[2];
c_datap -= __offsp[3];
out_datap -= __offsp[4];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_F: {
	PDL_Float * x_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Float * x_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));

	PDL_Float * dat_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Float * dat_physdatap = ((PDL_Float *)((__privtrans->pdls[1])->data));

	PDL_Float * xloc_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Float * xloc_physdatap = ((PDL_Float *)((__privtrans->pdls[2])->data));

	PDL_Float * c_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Float * c_physdatap = ((PDL_Float *)((__privtrans->pdls[3])->data));

	PDL_Float * out_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Float * out_physdatap = ((PDL_Float *)((__privtrans->pdls[4])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];x_datap += __offsp[0];
dat_datap += __offsp[1];
xloc_datap += __offsp[2];
c_datap += __offsp[3];
out_datap += __offsp[4];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_dat_k = __privtrans->__inc_dat_k;
register PDL_Long __inc_x_k = __privtrans->__inc_x_k;

	long i;
	long dex;
	long dexlo;
        double xlo;
        double xhi;
        double x;
	long dexhi;
        double p[4];
       double xp[4];
       long n;

       n = __privtrans->__k_size;

              {
	   	   dexlo = 0;
	   dexhi = n-1;
	   xlo = (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, 0))] PDL_COMMENT("ACCESS()") ;
	   xhi = (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, n-1))] PDL_COMMENT("ACCESS()") ;
	   dex = dexhi;

	   while((dexlo < dexhi - 1)) {
	       dex = (dexlo + dexhi)/2;
	       if(dex >= 0) {
		 x = (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, dex))] PDL_COMMENT("ACCESS()") ;
		 if(x > (xloc_datap)[0] PDL_COMMENT("ACCESS()") ) {
		   dexhi = dex;
		   xhi = x;
		 } else {
		   dexlo = dex;
		   xlo = x;
		 }
		 if(xlo >= xhi)
		   barf("data source is non monotonic!\n");
	       }
	   }
       }

                     
              printf("val=%g, dex=%d\\n",(float)(xloc_datap)[0] PDL_COMMENT("ACCESS()") , $dex);
       dex = dexlo - 1;
       for(i=0; i<4; i++,dex++) {
	   if(dex<0 || dex > n-1) {
	       p[i]   = (dex<0) ? (dat_datap)[0+(__inc_dat_k*PP_INDTERM(__privtrans->__k_size, 0))] PDL_COMMENT("ACCESS()")  : (dat_datap)[0+(__inc_dat_k*PP_INDTERM(__privtrans->__k_size, n-1))] PDL_COMMENT("ACCESS()") ; 
	       xp[i]  = (dex<0) ? ((x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, 0))] PDL_COMMENT("ACCESS()")  + ((x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, 1))] PDL_COMMENT("ACCESS()")  - (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, 0))] PDL_COMMENT("ACCESS()") ) * dex)   : (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, n-1))] PDL_COMMENT("ACCESS()")  + ((x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, n-1))] PDL_COMMENT("ACCESS()")  - (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, n-2))] PDL_COMMENT("ACCESS()") )*(dex - (n-1));
	       break;
	   } else {
	       p[i] = (dat_datap)[0+(__inc_dat_k*PP_INDTERM(__privtrans->__k_size, dex))] PDL_COMMENT("ACCESS()") ;
	       xp[i] = (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, dex))] PDL_COMMENT("ACCESS()") ;
	   }
       }

              {
	   if(xp[3]==xp[2]) 
	       xp[3]++;
	   if(xp[0] == xp[1]) 
	       xp[0]--;

	   double t = ((xloc_datap)[0] PDL_COMMENT("ACCESS()")  - xlo) / (xp[2]-xlo);
	   double t1 = 1 - t;
	   double h00 = (1 + 2*t) * t1 * t1;
	   double h10 = t * t1 * t1;
	   double h01 = t * t * (3 - 2*t);
	   double h11 = - t * t * t1;

	   double m0 = (1 - (c_datap)[0] PDL_COMMENT("ACCESS()") ) * 0.5 * ( (p[2] - p[1]) / (xp[2]-xp[1]) + (p[1]-p[0]) / (xp[1]-xp[0]));
	   double m1 = (1 - (c_datap)[0] PDL_COMMENT("ACCESS()") ) * 0.5 * ( (p[3] - p[2]) / (xp[3]-xp[2]) + (p[2]-p[1]) / (xp[1]-xp[0]));

	 (out_datap)[0] PDL_COMMENT("ACCESS()")  = h00 * p[1] + h10 * m0 * (xp[2]-xlo) + h01 * p[2] + h11 * m1 * (xp[2]-xlo);
       }



}	PDL_COMMENT("THREADLOOPEND")
	 x_datap += __tinc0_0;
dat_datap += __tinc0_1;
xloc_datap += __tinc0_2;
c_datap += __tinc0_3;
out_datap += __tinc0_4;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
dat_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
xloc_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
c_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
out_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;dat_datap -= __tinc1_1 *
     				  __tdims1;xloc_datap -= __tinc1_2 *
     				  __tdims1;c_datap -= __tinc1_3 *
     				  __tdims1;out_datap -= __tinc1_4 *
     				  __tdims1;
 x_datap -= __offsp[0];
dat_datap -= __offsp[1];
xloc_datap -= __offsp[2];
c_datap -= __offsp[3];
out_datap -= __offsp[4];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	} break; case PDL_D: {
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * dat_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * dat_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * xloc_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * xloc_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * c_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * c_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * out_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * out_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_COMMENT("THREADLOOPBEGIN")
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];x_datap += __offsp[0];
dat_datap += __offsp[1];
xloc_datap += __offsp[2];
c_datap += __offsp[3];
out_datap += __offsp[4];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
{register PDL_Long __inc_dat_k = __privtrans->__inc_dat_k;
register PDL_Long __inc_x_k = __privtrans->__inc_x_k;

	long i;
	long dex;
	long dexlo;
        double xlo;
        double xhi;
        double x;
	long dexhi;
        double p[4];
       double xp[4];
       long n;

       n = __privtrans->__k_size;

              {
	   	   dexlo = 0;
	   dexhi = n-1;
	   xlo = (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, 0))] PDL_COMMENT("ACCESS()") ;
	   xhi = (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, n-1))] PDL_COMMENT("ACCESS()") ;
	   dex = dexhi;

	   while((dexlo < dexhi - 1)) {
	       dex = (dexlo + dexhi)/2;
	       if(dex >= 0) {
		 x = (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, dex))] PDL_COMMENT("ACCESS()") ;
		 if(x > (xloc_datap)[0] PDL_COMMENT("ACCESS()") ) {
		   dexhi = dex;
		   xhi = x;
		 } else {
		   dexlo = dex;
		   xlo = x;
		 }
		 if(xlo >= xhi)
		   barf("data source is non monotonic!\n");
	       }
	   }
       }

                     
              printf("val=%g, dex=%d\\n",(float)(xloc_datap)[0] PDL_COMMENT("ACCESS()") , $dex);
       dex = dexlo - 1;
       for(i=0; i<4; i++,dex++) {
	   if(dex<0 || dex > n-1) {
	       p[i]   = (dex<0) ? (dat_datap)[0+(__inc_dat_k*PP_INDTERM(__privtrans->__k_size, 0))] PDL_COMMENT("ACCESS()")  : (dat_datap)[0+(__inc_dat_k*PP_INDTERM(__privtrans->__k_size, n-1))] PDL_COMMENT("ACCESS()") ; 
	       xp[i]  = (dex<0) ? ((x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, 0))] PDL_COMMENT("ACCESS()")  + ((x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, 1))] PDL_COMMENT("ACCESS()")  - (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, 0))] PDL_COMMENT("ACCESS()") ) * dex)   : (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, n-1))] PDL_COMMENT("ACCESS()")  + ((x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, n-1))] PDL_COMMENT("ACCESS()")  - (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, n-2))] PDL_COMMENT("ACCESS()") )*(dex - (n-1));
	       break;
	   } else {
	       p[i] = (dat_datap)[0+(__inc_dat_k*PP_INDTERM(__privtrans->__k_size, dex))] PDL_COMMENT("ACCESS()") ;
	       xp[i] = (x_datap)[0+(__inc_x_k*PP_INDTERM(__privtrans->__k_size, dex))] PDL_COMMENT("ACCESS()") ;
	   }
       }

              {
	   if(xp[3]==xp[2]) 
	       xp[3]++;
	   if(xp[0] == xp[1]) 
	       xp[0]--;

	   double t = ((xloc_datap)[0] PDL_COMMENT("ACCESS()")  - xlo) / (xp[2]-xlo);
	   double t1 = 1 - t;
	   double h00 = (1 + 2*t) * t1 * t1;
	   double h10 = t * t1 * t1;
	   double h01 = t * t * (3 - 2*t);
	   double h11 = - t * t * t1;

	   double m0 = (1 - (c_datap)[0] PDL_COMMENT("ACCESS()") ) * 0.5 * ( (p[2] - p[1]) / (xp[2]-xp[1]) + (p[1]-p[0]) / (xp[1]-xp[0]));
	   double m1 = (1 - (c_datap)[0] PDL_COMMENT("ACCESS()") ) * 0.5 * ( (p[3] - p[2]) / (xp[3]-xp[2]) + (p[2]-p[1]) / (xp[1]-xp[0]));

	 (out_datap)[0] PDL_COMMENT("ACCESS()")  = h00 * p[1] + h10 * m0 * (xp[2]-xlo) + h01 * p[2] + h11 * m1 * (xp[2]-xlo);
       }



}	PDL_COMMENT("THREADLOOPEND")
	 x_datap += __tinc0_0;
dat_datap += __tinc0_1;
xloc_datap += __tinc0_2;
c_datap += __tinc0_3;
out_datap += __tinc0_4;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
dat_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
xloc_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
c_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
out_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;dat_datap -= __tinc1_1 *
     				  __tdims1;xloc_datap -= __tinc1_2 *
     				  __tdims1;c_datap -= __tinc1_3 *
     				  __tdims1;out_datap -= __tinc1_4 *
     				  __tdims1;
 x_datap -= __offsp[0];
dat_datap -= __offsp[1];
xloc_datap -= __offsp[2];
c_datap -= __offsp[3];
out_datap -= __offsp[4];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_my_cspline_irregular_free(pdl_trans *__tr ) {
	int __dim;
	pdl_my_cspline_irregular_struct *__privtrans = (pdl_my_cspline_irregular_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;
			}
			
	}
    }
    



static char pdl_my_cspline_irregular_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_my_cspline_irregular_vtable = {
		0,0, 4, 5, pdl_my_cspline_irregular_vtable_flags,
		pdl_my_cspline_irregular_redodims, pdl_my_cspline_irregular_readdata, NULL,
		pdl_my_cspline_irregular_free,NULL,NULL,pdl_my_cspline_irregular_copy,NULL,
		sizeof(pdl_my_cspline_irregular_struct),"pdl_my_cspline_irregular_vtable",
		NULL
	 };



#line 1428 "eval_101_638e.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 1480 "eval_101_638e.c"

XS(XS_eval_101_638e_set_debugging); /* prototype to pass -Wmissing-prototypes */
XS(XS_eval_101_638e_set_debugging)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "i");
    {
	int	i = (int)SvIV(ST(0));
	int	RETVAL;
	dXSTARG;
#line 1426 "eval_101_638e.xs"
	RETVAL = __pdl_debugging;
	__pdl_debugging = i;
#line 1499 "eval_101_638e.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_eval_101_638e_set_boundscheck); /* prototype to pass -Wmissing-prototypes */
XS(XS_eval_101_638e_set_boundscheck)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "i");
    {
	int	i = (int)SvIV(ST(0));
	int	RETVAL;
	dXSTARG;
#line 1435 "eval_101_638e.xs"
       if (! 1)
         warn("Bounds checking is disabled for eval_101_638e");
       RETVAL = __pdl_boundscheck;
       __pdl_boundscheck = i;
#line 1525 "eval_101_638e.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_PDL_my_cspline_irregular); /* prototype to pass -Wmissing-prototypes */
XS(XS_PDL_my_cspline_irregular)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 1449 "eval_101_638e.xs"
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *out_SV;
  pdl  *x;
  pdl  *dat;
  pdl  *xloc;
  pdl  *c;
  pdl  *out;
  char  bound;
#line 1557 "eval_101_638e.c"
#line 1462 "eval_101_638e.xs"
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
  }
  if (items == 6) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    dat = PDL->SvPDLV(ST(1));
    xloc = PDL->SvPDLV(ST(2));
    c = PDL->SvPDLV(ST(3));
    out = PDL->SvPDLV(ST(4));
    bound = (char)*SvPV_nolen(ST(5))
;
  }
  else if (items == 5) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 1;
    x = PDL->SvPDLV(ST(0));
    dat = PDL->SvPDLV(ST(1));
    xloc = PDL->SvPDLV(ST(2));
    c = PDL->SvPDLV(ST(3));
    bound = (char)*SvPV_nolen(ST(4))
;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       out_SV = sv_newmortal();
       out = PDL->null();
       PDL->SetSV_PDL(out_SV,out);
       if (bless_stash) out_SV = sv_bless(out_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       out_SV = POPs;
       PUTBACK;
       out = PDL->SvPDLV(out_SV);
    }
  }
  else {
    croak ("Usage:  PDL::my_cspline_irregular(x,dat,xloc,c,out,bound) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_my_cspline_irregular_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_my_cspline_irregular_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((x->state & PDL_BADVAL) > 0) || ((dat->state & PDL_BADVAL) > 0) || ((xloc->state & PDL_BADVAL) > 0) || ((c->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < x->datatype) {
		 	__privtrans->__datatype = x->datatype;
		    }
if(__privtrans->__datatype < dat->datatype) {
		 	__privtrans->__datatype = dat->datatype;
		    }
if(__privtrans->__datatype < xloc->datatype) {
		 	__privtrans->__datatype = xloc->datatype;
		    }
if(__privtrans->__datatype < c->datatype) {
		 	__privtrans->__datatype = c->datatype;
		    }
if(!((out->state & PDL_NOMYDIMS) &&
		       out->trans == NULL) && __privtrans->__datatype < out->datatype) {
		 	__privtrans->__datatype = out->datatype;
		    }
if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != x->datatype) {
	     x = PDL->get_convertedpdl(x,__privtrans->__datatype);
	  }if(__privtrans->__datatype != dat->datatype) {
	     dat = PDL->get_convertedpdl(dat,__privtrans->__datatype);
	  }if(__privtrans->__datatype != xloc->datatype) {
	     xloc = PDL->get_convertedpdl(xloc,__privtrans->__datatype);
	  }if(__privtrans->__datatype != c->datatype) {
	     c = PDL->get_convertedpdl(c,__privtrans->__datatype);
	  }if( (out->state & PDL_NOMYDIMS) && out->trans == NULL ) {
	     out->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != out->datatype) {
	     out = PDL->get_convertedpdl(out,__privtrans->__datatype);
	  }{(__privtrans->bound) = (bound);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = x;
__privtrans->pdls[1] = dat;
__privtrans->pdls[2] = xloc;
__privtrans->pdls[3] = c;
__privtrans->pdls[4] = out;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  out->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = out_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 1673 "eval_101_638e.c"
	PUTBACK;
	return;
    }
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_eval_101_638e); /* prototype to pass -Wmissing-prototypes */
XS(boot_eval_101_638e)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        (void)newXSproto_portable("eval_101_638e::set_debugging", XS_eval_101_638e_set_debugging, file, "$");
        (void)newXSproto_portable("eval_101_638e::set_boundscheck", XS_eval_101_638e_set_boundscheck, file, "$");
        (void)newXSproto_portable("PDL::my_cspline_irregular", XS_PDL_my_cspline_irregular, file, ";@");

    /* Initialisation Section */

#line 1579 "eval_101_638e.xs"

   PDL_COMMENT("Get pointer to structure of core shared C routines")
   PDL_COMMENT("make sure PDL::Core is loaded")
   perl_require_pv("PDL::Core");
   CoreSV = perl_get_sv("PDL::SHARE",FALSE);  PDL_COMMENT("SV* value")
#ifndef aTHX_
#define aTHX_
#endif
   if (CoreSV==NULL)
     Perl_croak(aTHX_ "Can't load PDL::Core module");
   PDL = INT2PTR(Core*, SvIV( CoreSV ));  PDL_COMMENT("Core* value")
   if (PDL->Version != PDL_CORE_VERSION)
     Perl_croak(aTHX_ "[PDL->Version: %d PDL_CORE_VERSION: %d XS_VERSION: %s] eval_101_638e needs to be recompiled against the newly installed PDL", PDL->Version, PDL_CORE_VERSION, XS_VERSION);

#line 1721 "eval_101_638e.c"

    /* End of Initialisation Section */

#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

